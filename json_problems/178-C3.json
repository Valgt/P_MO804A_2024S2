{
    "uid": "178-C3",
    "url": "https://codeforces.com/contest/178/problem/C3",
    "tags": [],
    "title": "178-C3",
    "statement": "C3. Smart Beaver and Resolving Collisionstime limit per test1 secondmemory limit per test256 megabytesinputstdinoutputstdoutThe Smart Beaver from ABBYY has a lot of hobbies. One of them is constructing efficient hash tables. One of the most serious problems in hash tables is resolving collisions. The Beaver is interested in this problem very much and he decided to explore it in detail.We assume that the hash table consists ofhcells numbered from0toh- 1. Objects are added to and removed from it. Every object has its own unique identifier. In addition, every object has a corresponding hash value — an integer between0andh- 1, inclusive. When an object is added to the table, if the cell corresponding to the hash value of the object is free, then this object goes there. If the cell is already occupied by another object, there is a collision. When an object is deleted from the table, the cell which it occupied becomes empty.The Smart Beaver has recently learned about the method of linear probing to resolve collisions. It is as follows. Let's say that the hash value for the added object equalstand celltof the table is already occupied. Then we try to add this object to cell(t+m)modh. If it is also occupied, then we try cell(t+ 2·m)modh, then cell(t+ 3·m)modh, and so on. Note that in some cases it's possible that the new object can not be added to the table.It is guaranteed that the input for this problem doesn't contain such situations.The operationamodbmeans that we take the remainder of the division of numberaby numberb.This technique immediately seemed very inoptimal to the Beaver, and he decided to assess its inefficiency. So, you are given a sequence of operations, each of which is either an addition of an object to the table or a deletion of an object from the table. When adding a new object, a sequence of calls to the table is performed. Calls to occupied cells are called dummy. In other words, if the result of the algorithm described above is the object being added to cell(t+i·m)modh(i≥ 0), then exactlyidummy calls have been performed.Your task is to calculate the total number of dummy calls to the table for the given sequence of additions and deletions. When an object is deleted from the table, assume that no dummy calls are performed. The table is empty before performing the operations, that is, initially it doesn't contain any objects.InputThe first line of input contains three integersh,mandn(1 ≤m<h), separated by spaces, wherehis the size of the hash table,mis the number that is used to resolve collisions,nis the number of operations.The followingnlines contains the descriptions of the operations. Their execution order corresponds to the order in which they appear in the input file. Each operation is described by a single line. The operations are described as follows:\"+ id hash\"This is the format of the operation that adds an object to the table. The first character is \"+\" (ASCII 43), followed by a single space, then the object identifierid(0 ≤id≤ 109), then another space, and the hash value of the given objecthash(0 ≤hash<h). The object identifier and the hash value of this object are integers.\"- id\"This is the format of the operation that deletes an object from the table. The first character is \"-\" (ASCII 45), followed by a single space, then the object identifierid(0 ≤id≤ 109). The object identifier is an integer.It is guaranteed that for all addition operations the value ofidis unique. It is also guaranteed that the initial data is correct, that is, it's always possible to add an object to the hash table and there won't be any deletions of nonexisting objects.The input limitations for getting 20 points are:1 ≤h≤ 50001 ≤n≤ 5000The input limitations for getting 50 points are:1 ≤h≤ 5·1041 ≤n≤ 5·104The input limitations for getting 100 points are:1 ≤h≤ 2·1051 ≤n≤ 2·105OutputPrint a single number — the total number of dummy calls to the hash table.Please, do not use the%lldspecifier to read or write 64-bit integers in С++. It is preferred to usecin,coutstreams and the%I64dspecifier.ExamplesInput10 2 7+ 11 0+ 22 2+ 33 6+ 44 0+ 55 0- 22+ 66 0Output7Input5 1 6+ 123 0+ 234 1+ 345 2- 234+ 456 0+ 567 0Output4",
    "source": "CF",
    "vjudge": false
}