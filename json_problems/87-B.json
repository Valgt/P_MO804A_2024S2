{
    "uid": "87-B",
    "url": "https://codeforces.com/contest/87/problem/B",
    "tags": [
        "implementation",
        " strings"
    ],
    "title": "87-B",
    "statement": "B. Vasya and Typestime limit per test1 secondmemory limit per test256 megabytesinputstdinoutputstdoutProgrammer Vasya is studying a new programming language &K*. The &K* language resembles the languages of the C family in its syntax. However, it is more powerful, which is why the rules of the actual C-like languages are unapplicable to it. To fully understand the statement, please read the language's description below carefully and follow it and not the similar rules in real programming languages.There is a very powerful system of pointers on &K* — you can add an asterisk to the right of the existing typeX— that will result in new typeX*. That is called pointer-definition operation. Also, there is the operation that does the opposite — to any type ofX, which is a pointer, you can add an ampersand — that will result in a type&X, to which refersX. That is called a dereference operation.The &K* language has only two basic data types —voidanderrtype. Also, the language has operatorstypedefandtypeof.The operator \"typedefAB\" defines a new data typeB, which is equivalent toA.Acan have asterisks and ampersands, andBcannot have them. For example, the operatortypedef void** ptptvoidwill create a new typeptptvoid, that can be used asvoid**.The operator \"typeofA\" returns type ofA, brought tovoid, that is, returns the typevoid**...*, equivalent to it with the necessary number of asterisks (the number can possibly be zero). That is, having defined theptptvoidtype, as shown above, thetypeof ptptvoidoperator will returnvoid**.An attempt of dereferencing of thevoidtype will lead to an error: to a special data typeerrtype. Forerrtypethe following equation holds true:errtype*=&errtype=errtype. An attempt to use the data type that hasn't been defined before that will also lead to theerrtype.Usingtypedef, we can define one type several times. Of all the definitions only the last one is valid. However, all the types that have been defined earlier using this type do not change.Let us also note that the dereference operation has the lower priority that the pointer operation, in other words&T*is always equal toT.Note, that the operators are executed consecutively one by one. If we have two operators \"typedef &void a\" and \"typedef a* b\", then at firstabecomeserrtype, and after thatbbecomeserrtype* = errtype, butnot&void* = void(see sample 2).Vasya does not yet fully understand this powerful technology, that's why he asked you to help him. Write a program that analyzes these operators.InputThe first line contains an integern(1 ≤n≤ 100) — the number of operators. Then follownlines with operators. Each operator is of one of two types: either \"typedefAB\", or \"typeofA\". In the first case theBtype differs fromvoidanderrtypetypes, and besides, doesn't have any asterisks and ampersands.All the data type names are non-empty lines of no more than 20 lowercase Latin letters. The number of asterisks and ampersands separately in one type in any operator does not exceed 10, however if we bring some types tovoidwith several asterisks, their number may exceed 10.OutputFor everytypeofoperator print on the single line the answer to that operator — the type that the given operator returned.ExamplesInput5typedef void* ptvtypeof ptvtypedef &&ptv nodetypeof nodetypeof &ptvOutputvoid*errtypevoidInput17typedef void* btypedef b* ctypeof btypeof ctypedef &b btypeof btypeof ctypedef &&b* ctypeof ctypedef &b* ctypeof ctypedef &void btypeof btypedef b******* ctypeof ctypedef &&b* ctypeof cOutputvoid*void**voidvoid**errtypevoiderrtypeerrtypeerrtypeNoteLet's look at the second sample.After the first two queriestypedefthebtype is equivalent tovoid*, andc— tovoid**.The next querytypedefredefinesb— it is now equal to&b = &void* = void. At that, thectype doesn't change.After that thectype is defined as&&b* = &&void* = &void = errtype. It doesn't influence thebtype, that's why the nexttypedefdefinescas&void* = void.Then thebtype is again redefined as&void = errtype.Please note that thectype in the next query is defined exactly aserrtype******* = errtype, and not&void******* = void******. The same happens in the lasttypedef.",
    "source": "CF",
    "vjudge": false
}