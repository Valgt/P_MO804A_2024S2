{
    "uid": "901-C",
    "url": "https://codeforces.com/contest/901/problem/C",
    "tags": [
        "binary search",
        " data structures",
        " dfs and similar",
        " dsu",
        " graphs",
        " two pointers"
    ],
    "title": "901-C",
    "statement": "C. Bipartite Segmentstime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputYou are given an undirected graph withnvertices. There are no edge-simple cycles with the even length in it. In other words, there are no cycles of even length that pass each edge at most once. Let's enumerate vertices from1ton.You have to answerqqueries. Each query is described by a segment of vertices[l;r], and you have to count the number of its subsegments[x;y](l≤x≤y≤r), such that if we delete all vertices except the segment of vertices[x;y](includingxandy) and edges between them, the resulting graph is bipartite.InputThe first line contains two integersnandm(1 ≤n≤ 3·105,1 ≤m≤ 3·105) — the number of vertices and the number of edges in the graph.The nextmlines describe edges in the graph. Thei-th of these lines contains two integersaiandbi(1 ≤ai,bi≤n;ai≠bi), denoting an edge between verticesaiandbi. It is guaranteed that this graph does not contain edge-simple cycles of even length.The next line contains a single integerq(1 ≤q≤ 3·105) — the number of queries.The nextqlines contain queries. Thei-th of these lines contains two integersliandri(1 ≤li≤ri≤n) — the query parameters.OutputPrintqnumbers, each in new line: thei-th of them should be the number of subsegments[x;y](li≤x≤y≤ri), such that the graph that only includes vertices from segment[x;y]and edges between them is bipartite.ExamplesInput6 61 22 33 14 55 66 431 34 61 6Output5514Input8 91 22 33 14 55 66 77 88 47 231 81 43 8Output27819NoteThe first example is shown on the picture below:For the first query, all subsegments of[1; 3], except this segment itself, are suitable.For the first query, all subsegments of[4; 6], except this segment itself, are suitable.For the third query, all subsegments of[1; 6]are suitable, except[1; 3],[1; 4],[1; 5],[1; 6],[2; 6],[3; 6],[4; 6].The second example is shown on the picture below:",
    "source": "CF",
    "vjudge": false
}