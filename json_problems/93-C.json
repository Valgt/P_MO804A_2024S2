{
    "uid": "93-C",
    "url": "https://codeforces.com/contest/93/problem/C",
    "tags": [
        "brute force",
        " implementation"
    ],
    "title": "93-C",
    "statement": "C. Azemblertime limit per test5 secondsmemory limit per test256 megabytesinputstdinoutputstdoutAfter the Search Ultimate program that searched for strings in a text failed, Igor K. got to think: \"Why on Earth does my program work so slowly?\" As he double-checked his code, he said: \"My code contains no errors, yet I know how we will improve Search Ultimate!\" and took a large book from the shelves. The book read \"Azembler. Principally New Approach\".Having carefully thumbed through the book, Igor K. realised that, as it turns out, you can multiply the numbers dozens of times faster. \"Search Ultimate will be faster than it has ever been!\" — the fellow shouted happily and set to work.Let us now clarify what Igor's idea was. The thing is that the code that was generated by a compiler was far from perfect. Standard multiplying does work slower than with the trick the book mentioned.The Azembler language operates with 26 registers (eax, ebx, ..., ezx) and two commands:[x] — returns the value located in the addressx. For example, [eax] returns the value that was located in the address, equal to the value in the register eax.leax,y— assigns to the registerx, indicated as the first operand, the second operand's address. Thus, for example, the \"lea ebx, [eax]\" command will write in the ebx register the content of the eax register: first the [eax] operation will be fulfilled, the result of it will be some value that lies in the address written in eax. But we do not need the value — the next operation will be lea, that will take the [eax] address, i.e., the value in the eax register, and will write it in ebx.On the first thought the second operation seems meaningless, but as it turns out, it is acceptable to write the operation aslea ecx, [eax + ebx],lea ecx, [k*eax]or evenlea ecx, [ebx + k*eax],where k = 1, 2, 4 or 8.As a result, the register ecx will be equal to the numbers eax + ebx, k*eax and ebx + k*eax correspondingly. However, such operation is fulfilled many times, dozens of times faster that the usual multiplying of numbers. And using several such operations, one can very quickly multiply some number by some other one. Of course, instead of eax, ebx and ecx you are allowed to use any registers.For example, let the eax register contain some number that we should multiply by 41. It takes us 2 lines:lea ebx, [eax + 4*eax] // now ebx = 5*eaxlea eax, [eax + 8*ebx] // now eax = eax + 8*ebx = 41*eaxIgor K. got interested in the following question: what is the minimum number of lea operations needed to multiply by the given numbernand how to do it? Your task is to help him.Consider that at the initial moment of time eax contains a number that Igor K. was about to multiply byn, and the registers from ebx to ezx contain number 0. At the final moment of time the result can be located in any register.InputThe input data contain the only integern(1 ≤n≤ 255), which Igor K. is about to multiply.OutputOn the first line print numberp, which represents the minimum number of lea operations, needed to do that. Then print the program consisting ofpcommands, performing the operations. It is guaranteed that such program exists for anynfrom 1 to 255.Use precisely the following format of commands (herekis equal to 1, 2, 4 or 8, andx,yandzare any, even coinciding registers):lea x, [y]lea x, [y + z]lea x, [k*y]lea x, [y + k*z]Please note thatextra spaces at the end of a command are unacceptable.ExamplesInput41Output2lea ebx, [eax + 4*eax]lea ecx, [eax + 8*ebx]Input2Output1lea ebx, [eax + eax]Input4Output1lea ebx, [4*eax]",
    "source": "CF",
    "vjudge": false
}