{
    "uid": "620-D",
    "url": "https://codeforces.com/contest/620/problem/D",
    "tags": [
        "binary search",
        " two pointers"
    ],
    "title": "620-D",
    "statement": "D. Professor GukiZ and Two Arraystime limit per test3 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputProfessor GukiZ has two arrays of integers,aandb. Professor wants to make the sum of the elements in the arrayasaas close as possible to the sum of the elements in the arraybsb. So he wants to minimize the valuev= |sa-sb|.In one operation professor can swap some element from the arrayaand some element from the arrayb. For example if the arrayais[5, 1, 3, 2, 4]and the arraybis[3, 3, 2]professor can swap the element5from the arrayaand the element2from the arrayband get the new arraya[2, 1, 3, 2, 4]and the new arrayb[3, 3, 5].Professor doesn't want to make more than two swaps. Find the minimal valuevand some sequence of no more than two swaps that will lead to the such valuev. Professor makes swaps one by one, each new swap he makes with the new arraysaandb.InputThe first line contains integern(1 ≤n≤ 2000) — the number of elements in the arraya.The second line containsnintegersai(- 109≤ai≤ 109) — the elements of the arraya.The third line contains integerm(1 ≤m≤ 2000) — the number of elements in the arrayb.The fourth line containsmintegersbj(- 109≤bj≤ 109) — the elements of the arrayb.OutputIn the first line print the minimal valuev= |sa-sb|that can be got with no more than two swaps.The second line should contain the number of swapsk(0 ≤k≤ 2).Each of the nextklines should contain two integersxp,yp(1 ≤xp≤n, 1 ≤yp≤m) — the index of the element in the arrayaand the index of the element in the arraybin thep-th swap.If there are several optimal solutions print any of them. Print the swaps in order the professor did them.ExamplesInput55 4 3 2 141 1 1 1Output121 14 2Input51 2 3 4 5115Output00Input51 2 3 4 541 2 3 4Output113 1",
    "source": "CF",
    "vjudge": false
}