{
    "uid": "570-C",
    "url": "https://codeforces.com/contest/570/problem/C",
    "tags": [
        "constructive algorithms",
        " data structures",
        " implementation"
    ],
    "title": "570-C",
    "statement": "C. Replacementtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputDaniel has a strings, consisting of lowercase English letters and period signs (characters '.'). Let's define the operation ofreplacementas the following sequence of steps: find a substring \"..\" (two consecutive periods) in strings, of all occurrences of the substring let's choose the first one, and replace this substring with string \".\". In other words, during the replacement operation, the first two consecutive periods are replaced by one. If stringscontains no two consecutive periods, then nothing happens.Let's definef(s)as the minimum number of operations ofreplacementto perform, so that the string does not have any two consecutive periods left.You need to processmqueries, thei-th results in that the character at positionxi(1 ≤xi≤n) of stringsis assigned valueci. After each operation you have to calculate and output the value off(s).Help Daniel to process all queries.InputThe first line contains two integersnandm(1 ≤n,m≤ 300 000) the length of the string and the number of queries.The second line contains strings, consisting ofnlowercase English letters and period signs.The followingmlines contain the descriptions of queries. Thei-th line contains integerxiandci(1 ≤xi≤n,ci— a lowercas English letter or a period sign), describing the query of assigning symbolcito positionxi.OutputPrintmnumbers, one per line, thei-th of these numbers must be equal to the value off(s)after performing thei-th assignment.ExamplesInput10 3.b..bz....1 h3 c9 fOutput431Input4 4.cc.2 .3 .2 a1 aOutput1311NoteNote to the first sample test (replaced periods are enclosed in square brackets).The original string is \".b..bz....\".after the first queryf(hb..bz....)= 4    (\"hb[..]bz....\"→\"hb.bz[..]..\"→\"hb.bz[..].\"→\"hb.bz[..]\"→\"hb.bz.\")after the second queryf(hbс.bz....)= 3    (\"hbс.bz[..]..\"→\"hbс.bz[..].\"→\"hbс.bz[..]\"→\"hbс.bz.\")after the third queryf(hbс.bz..f.)= 1    (\"hbс.bz[..]f.\"→\"hbс.bz.f.\")Note to the second sample test.The original string is \".cc.\".after the first query:f(..c.)= 1    (\"[..]c.\"→\".c.\")after the second query:f(....)= 3    (\"[..]..\"→\"[..].\"→\"[..]\"→\".\")after the third query:f(.a..)= 1    (\".a[..]\"→\".a.\")after the fourth query:f(aa..)= 1    (\"aa[..]\"→\"aa.\")",
    "source": "CF",
    "vjudge": false
}