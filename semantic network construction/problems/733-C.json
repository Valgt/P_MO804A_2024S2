{"uid": "733-C", "url": "https://codeforces.com/contest/733/problem/C", "tags": ["constructive algorithms", " dp", " greedy", " two pointers"], "title": "733-C", "statement": "C. Epidemic in Monstropolistime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputThere was an epidemic in Monstropolis and all monsters became sick. To recover, all monsters lined up in queue for an appointment to the only doctor in the city.Soon, monsters became hungry and began to eat each other.One monster can eat other monster if its weight isstrictly greaterthan the weight of the monster being eaten, and they stand in the queue next to each other. Monsters eat each other instantly. There are no monsters which are being eaten at the same moment. After the monsterAeats the monsterB, the weight of the monsterAincreases by the weight of the eaten monsterB. In result of such eating the length of the queue decreases by one, all monsters after the eaten one step forward so that there is no empty places in the queue again. A monster can eat several monsters one after another. Initially there werenmonsters in the queue, thei-th of which had weightai.For example, if weights are[1, 2, 2, 2, 1, 2](in order of queue, monsters are numbered from1to6from left to right) then some of the options are:the first monster can't eat the second monster becausea1= 1is not greater thana2= 2;the second monster can't eat the third monster becausea2= 2is not greater thana3= 2;the second monster can't eat the fifth monster because they are not neighbors;the second monster can eat the first monster, the queue will be transformed to[3, 2, 2, 1, 2].After some time, someone said a good joke and all monsters recovered. At that moment there werek(k≤n) monsters in the queue, thej-th of which had weightbj. Both sequences (aandb) contain the weights of the monsters in the order from the first to the last.You are required to provide one of the possible orders of eating monsters which led to the current queue, or to determine that this could not happen. Assume that the doctor didn't make any appointments while monsters were eating each other.InputThe first line contains single integern(1 ≤n≤ 500) — the number of monsters in the initial queue.The second line containsnintegersa1,a2, ...,an(1 ≤ai≤ 106) — the initial weights of the monsters.The third line contains single integerk(1 ≤k≤n) — the number of monsters in the queue after the joke.The fourth line containskintegersb1,b2, ...,bk(1 ≤bj≤ 5·108) — the weights of the monsters after the joke.Monsters are listed in the order from the beginning of the queue to the end.OutputIn case if no actions could lead to the final queue, print \"NO\" (without quotes) in the only line.Otherwise print \"YES\" (without quotes) in the first line. In the nextn-klines print actions in the chronological order. In each line printx— the index number of the monster in the current queue which eats and, separated by space, the symbol 'L' if the monster which stays thex-th in the queue eats the monster in front of him, or 'R' if the monster which stays thex-th in the queue eats the monster behind him. After each eating the queue is enumerated again.When one monster eats another the queue decreases. If there are several answers, print any of them.ExamplesInput61 2 2 2 1 225 5OutputYES2 L1 R4 L3 LInput51 2 3 4 5115OutputYES5 L4 L3 L2 LInput51 1 1 3 332 1 6OutputNONoteIn the first example, initially there weren= 6monsters, their weights are[1, 2, 2, 2, 1, 2](in order of queue from the first monster to the last monster). The final queue should be[5, 5]. The following sequence of eatings leads to the final queue:the second monster eats the monster to the left (i.e. the first monster), queue becomes[3, 2, 2, 1, 2];the first monster (note, it was the second on the previous step) eats the monster to the right (i.e. the second monster), queue becomes[5, 2, 1, 2];the fourth monster eats the mosnter to the left (i.e. the third monster), queue becomes[5, 2, 3];the finally, the third monster eats the monster to the left (i.e. the second monster), queue becomes[5, 5].Note that for each step the output contains numbers of the monsters in their current order in the queue.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "ccc5bc3f", "template_md5": "35d339e4", "result": "You are given two arrays, `a` and `b`, representing the weights of monsters in a queue at two different times. Initially, there are `n` monsters in the queue with weights `a1, a2, ..., an`.  Later, some monsters eat each other, and the queue shrinks to `k` monsters with weights `b1, b2, ..., bk`.\n\nA monster can eat another monster if its weight is strictly greater than the other monster's weight, and they are adjacent in the queue.  \n\nYour task is to determine if it's possible to have the final queue `b` by having monsters eat each other based on the initial queue `a`. If it's possible, output \"YES\" followed by a sequence of actions. Each action describes a monster eating another monster, specifying the index of the eating monster and the direction (\"L\" for left, \"R\" for right).\n\nIf it's impossible to reach the final queue `b` from the initial queue `a`, output \"NO\"."}, {"prompt_md5": "e080d3dd", "template_md5": "465699a0", "result": "You are given two lists of numbers representing the weights of items. The first list represents the initial weights, and the second list represents the weights after some items have been removed.  \n\nYou need to determine if it's possible to remove items from the first list to get the second list, following these rules:\n\n*  An item can only be removed if it is heavier than the item next to it.\n*  Removed items are not returned.\n\n\nIf it's possible, output \"YES\" followed by a sequence of steps describing which items were removed and in what order. If it's not possible, output \"NO\"."}]}