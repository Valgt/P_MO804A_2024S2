{"uid": "332-E", "url": "https://codeforces.com/contest/332/problem/E", "tags": ["dp", " greedy", " implementation"], "title": "332-E", "statement": "E. Binary Keytime limit per test4 secondsmemory limit per test256 megabytesinputstdinoutputstdoutLet's assume thatpandqare strings of positive length, called thecontainerand thekeycorrespondingly, stringqonly consists of characters 0 and 1. Let's take a look at a simple algorithm that extractsmessagesfrom the given containerp:i = 0;j = 0;s = <>;while i is less than the length of the string p{if q[j] == 1, then add to the right of string s character p[i];increase variables i, j by one;if the value of the variable j equals the length of the string q, then j = 0;}In the given pseudocodei,jare integer variables,sis a string, '=' is an assignment operator, '==' is a comparison operation, '[]' is the operation of obtaining the string character with the preset index, '<>' is an empty string. We suppose that in all strings the characters are numbered starting from zero.We understand that implementing such algorithm is quite easy, so your task is going to be slightly different. You need to construct the lexicographically minimum key of lengthk, such that when it is used, the algorithm given above extracts messagesfrom containerp(otherwise find out that such key doesn't exist).InputThe first two lines of the input are non-empty stringspands(1 ≤ |p| ≤ 106,1 ≤ |s| ≤ 200), describing the container and the message, correspondingly. The strings can contain any characters with the ASCII codes from 32 to 126, inclusive.The third line contains a single integerk(1 ≤k≤ 2000)— the key's length.OutputPrint the required key (string of lengthk, consisting only of characters 0 and 1). If the key doesn't exist, print the single character 0.ExamplesInputabacabaaba6Output100001Inputabacabaaba3Output0NoteStringx=x1x2...xpislexicographically smallerthan stringy=y1y2...yq, if eitherp<qandx1=y1,x2=y2, ... ,xp=yp, or there exists such integerr(0 ≤r<min(p,q))thatx1=y1,x2=y2, ... ,xr=yrandxr+ 1<yr+ 1. Symbols are compared according to their ASCII codes.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "28a1a150", "template_md5": "35d339e4", "result": "You are given a string $p$ (the container) and a string $s$ (the message).  The message $s$ is extracted from the container $p$ using the following algorithm:\n\n1. Initialize two indices, $i = 0$ and $j = 0$, and an empty string $s$.\n2. While $i$ is less than the length of $p$:\n   - If the character at index $j$ in the key $q$ is 1, append the character at index $i$ in $p$ to $s$.\n   - Increment both $i$ and $j$ by 1.\n   - If $j$ reaches the length of $q$, reset $j$ to 0.\n\nYour task is to find the lexicographically smallest key $q$ of length $k$ that will extract the message $s$ from the container $p$. If no such key exists, output 0. \n\n**Input:**\n\n* Line 1: The container string $p$\n* Line 2: The message string $s$\n* Line 3: The length of the key $k$\n\n**Output:**\n\n* The lexicographically smallest key $q$ of length $k$ that extracts $s$ from $p$.\n* If no such key exists, output 0."}, {"prompt_md5": "80db3a22", "template_md5": "465699a0", "result": "Given a long string (container) and a short string (message), find the shortest possible key (string of 0s and 1s) that, when used in a specific algorithm, will extract the message from the container. If no such key exists, output 0. \n\n\nThe algorithm works by:\n\n1.  Starting at the beginning of both the container and the key.\n2.  If the current character in the key is 1, take the corresponding character from the container and add it to a new string.\n3.  Move to the next character in both the container and the key.\n4.  If the end of the key is reached, go back to the beginning. \n\n\n\nThe key you find should be the lexicographically smallest possible."}]}