{"uid": "1736-D", "url": "https://codeforces.com/contest/1736/problem/D", "tags": ["constructive algorithms", " geometry", " greedy", " implementation", " strings"], "title": "1736-D", "statement": "D. Equal Binary Subsequencestime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputEverool has a binary string $$$s$$$ of length $$$2n$$$. Note that a binary string is a string consisting of only characters $$$0$$$ and $$$1$$$. He wants to partition $$$s$$$ into twodisjoint equalsubsequences. He needs your help to do it.You are allowed to do the following operationexactlyonce.You can choose any subsequence (possibly empty) of $$$s$$$ and rotate it right by one position.In other words, you can select a sequence of indices $$$b_1, b_2, \\\\ldots, b_m$$$, where $$$1 \\\\le b_1 < b_2 < \\\\ldots < b_m \\\\le 2n$$$. After that yousimultaneouslyset $$$$$$s_{b_1} := s_{b_m},$$$$$$ $$$$$$s_{b_2} := s_{b_1},$$$$$$ $$$$$$\\\\ldots,$$$$$$ $$$$$$s_{b_m} := s_{b_{m-1}}.$$$$$$Can you partition $$$s$$$ into twodisjoint equalsubsequences after performing the allowed operationexactlyonce?A partition of $$$s$$$ into two disjoint equal subsequences $$$s^p$$$ and $$$s^q$$$ is twoincreasingarrays of indices $$$p_1, p_2, \\\\ldots, p_n$$$ and $$$q_1, q_2, \\\\ldots, q_n$$$, such that each integer from $$$1$$$ to $$$2n$$$ is encountered in either $$$p$$$ or $$$q$$$ exactly once, $$$s^p = s_{p_1} s_{p_2} \\\\ldots s_{p_n}$$$, $$$s^q = s_{q_1} s_{q_2} \\\\ldots s_{q_n}$$$, and $$$s^p = s^q$$$.If it is not possible to partition after performing any kind of operation, report $$$-1$$$.If it is possible to do the operation and partition $$$s$$$ into two disjoint subsequences $$$s^p$$$ and $$$s^q$$$, such that $$$s^p = s^q$$$, print elements of $$$b$$$ and indices of $$$s^p$$$, i.Â e. the values $$$p_1, p_2, \\\\ldots, p_n$$$.InputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\\\le t \\\\le 10^5$$$). Description of the test cases follows.The first line of each test case contains a single integer $$$n$$$ ($$$1 \\\\le n \\\\le 10^5$$$), where $$$2n$$$ is the length of the binary string.The second line of each test case contains the binary string $$$s$$$ of length $$$2n$$$.It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^5$$$.OutputFor each test case, follow the following output format.If there is no solution, print $$$-1$$$.Otherwise,In the first line, print an integer $$$m$$$ ($$$0 \\\\leq m \\\\leq 2n$$$), followed by $$$m$$$ distinct indices $$$b_1$$$, $$$b_2$$$, ..., $$$b_m$$$(inincreasingorder).In the second line, print $$$n$$$ distinct indices $$$p_1$$$, $$$p_2$$$, ..., $$$p_n$$$ (inincreasingorder).If there are multiple solutions, print any.ExampleInput4 2 1010 3 100010 2 1111 2 1110Output0 1 2 2 3 5 1 2 5 3 2 3 4 1 4 -1NoteIn the first test case, $$$b$$$ is empty. So string $$$s$$$ is not changed. Now $$$s^p = s_1 s_2 = \\\\mathtt{10}$$$, and $$$s^q = s_3s_4 = \\\\mathtt{10}$$$.In the second test case, $$$b=[3,5]$$$. Initially $$$s_3=\\\\mathtt{0}$$$, and $$$s_5=\\\\mathtt{1}$$$. On performing the operation, we simultaneously set $$$s_3=\\\\mathtt{1}$$$, and $$$s_5=\\\\mathtt{0}$$$.So $$$s$$$ is updated to101000on performing the operation.Now if we take characters at indices $$$[1,2,5]$$$ in $$$s^p$$$, we get $$$s_1=\\\\mathtt{100}$$$. Also characters at indices $$$[3,4,6]$$$ are in $$$s^q$$$. Thus $$$s^q=100$$$. We are done as $$$s^p=s^q$$$.In fourth test case, it can be proved that it is not possible to partition the string after performing any operation.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "3982b9a5", "template_md5": "35d339e4", "result": "You are given a binary string of length $2n$. You can perform one operation: choose a subsequence of the string and rotate it one position to the right.  \n\nAfter this operation, can you divide the string into two equal-length subsequences where the subsequences are the same?\n\nIf yes, output the indices of the subsequence you rotated and the indices of one of the equal subsequences. If no such division is possible, output -1."}, {"prompt_md5": "e6a9c72f", "template_md5": "465699a0", "result": "You are given a binary string of even length. You can perform one operation: choose a subsequence of the string and rotate it one position to the right.  Can you divide the string into two equal-length subsequences that are the same after this operation? If so, output the indices of the subsequence you rotated and the indices of one of the resulting equal subsequences. If it's not possible, output -1."}]}