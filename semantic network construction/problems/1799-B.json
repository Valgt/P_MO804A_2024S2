{"uid": "1799-B", "url": "https://codeforces.com/contest/1799/problem/B", "tags": ["brute force", " constructive algorithms", " greedy", " math"], "title": "1799-B", "statement": "B. Equalize by Dividetime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputYou are given an array $$$a_1, a_2, \\\\ldots, a_n$$$ of positive integers.You can make this operation multiple (possibly zero) times:Choose two indices $$$i$$$, $$$j$$$ ($$$1 \\\\leq i, j \\\\leq n$$$, $$$i \\\\neq j$$$).Assign $$$a_i := \\\\lceil \\\\frac{a_i}{a_j} \\\\rceil$$$. Here $$$\\\\lceil x \\\\rceil$$$ denotes $$$x$$$ rounded up to the smallest integer $$$\\\\geq x$$$.Is it possible to make all array elements equal by some sequence of operations (possibly empty)? If yes, printanyway to do it in at most $$$30n$$$ operations.It can be proven, that under the problem constraints, if some way exists to make all elements equal, there exists a way with at most $$$30n$$$ operations.InputThe first line contains a single integer $$$t$$$ ($$$1 \\\\leq t \\\\leq 1000$$$) — the number of test cases. Descriptions of test cases follow.The first line of each test case description contains a single integer $$$n$$$ ($$$1 \\\\leq n \\\\leq 100$$$).The second line of each test case description contains $$$n$$$ integers $$$a_1, a_2, \\\\ldots, a_n$$$ ($$$1 \\\\leq a_i \\\\leq 10^9$$$).It is guaranteed, that the sum of $$$n$$$ for all test cases does not exceed $$$1000$$$.OutputFor each test case print a single integer $$$q$$$ ($$$-1 \\\\leq q \\\\leq 30n$$$). If $$$q=-1$$$, there is no solution, otherwise $$$q$$$ is equal to the number of operations.If $$$q \\\\geq 0$$$, on the next $$$q$$$ lines print two integers $$$i$$$, $$$j$$$ ($$$1 \\\\leq i, j \\\\leq n$$$, $$$i \\\\neq j$$$) — descriptions of operations.If there are multiple solutions, you can print any.ExampleInput10110031 1 122 125 534 3 243 3 4 422 10055 3 6 7 863 3 80 3 8 3419 40 19 55Output0 0 -1 0 2 1 3 2 1 4 3 1 4 2 1 3 2 4 6 2 1 2 1 2 1 2 1 2 1 2 1 8 5 2 4 2 3 2 1 3 1 3 2 1 4 1 5 1 4 5 1 3 1 3 1 3 1 9 4 2 2 1 1 2 1 2 3 2 3 2 1 4 2 4 3 4NoteIn the first and second, fourth test cases all numbers are equal, so it is possible to do nothing.In the third test case, it is impossible to make all numbers equal.In the fifth test case: $$$[\\\\color{red}{4}, 3, \\\\color{blue}{2}] \\\\to [\\\\color{blue}{2}, \\\\color{red}{3}, 2] \\\\to [2, 2, 2]$$$.In the sixth test case: $$$[\\\\color{blue}{3}, 3, \\\\color{red}{4}, 4] \\\\to [3, \\\\color{blue}{3}, 2, \\\\color{red}{4}] \\\\to [\\\\color{red}{3}, 3, \\\\color{blue}{2}, 2] \\\\to [2, \\\\color{red}{3}, 2, \\\\color{blue}{2}] \\\\to [2, 2, 2, 2]$$$.Here the red numbers are $$$i$$$ indices (that will be assigned), blue numbers are $$$j$$$ indices.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "14dfe5d3", "template_md5": "35d339e4", "result": "You are given an array of positive integers. You can perform the following operation any number of times:\n\n1. Choose two distinct indices $i$ and $j$ from the array.\n2. Update the element at index $i$ to be the smallest integer greater than or equal to $\\frac{a_i}{a_j}$.\n\nDetermine if it is possible to make all elements in the array equal using these operations. If it is possible, provide a sequence of operations that achieves this. \n\n**Input:**\n\n* The first line contains the number of test cases, $t$.\n* For each test case:\n    * The first line contains the number of elements in the array, $n$.\n    * The second line contains $n$ integers representing the elements of the array.\n\n**Output:**\n\n* For each test case:\n    * If it is not possible to make all elements equal, print $-1$.\n    * Otherwise, print the minimum number of operations required.\n    * On the following lines, print the indices $i$ and $j$ for each operation.\n\n**Constraints:**\n\n* $1 \\le t \\le 1000$\n* $1 \\le n \\le 100$\n* $1 \\le a_i \\le 10^9$\n* The sum of $n$ for all test cases does not exceed 1000."}, {"prompt_md5": "941e67e9", "template_md5": "465699a0", "result": "You are given a list of numbers. You can repeatedly divide a number in the list by another number in the list, rounding the result up to the nearest whole number.  Can you make all the numbers in the list equal using this operation? If so, show one way to do it using as few operations as possible."}]}