{"uid": "1115-U3", "url": "https://codeforces.com/contest/1115/problem/U3", "tags": ["*special"], "title": "1115-U3", "statement": "U3. Block unitarytime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputImplement a unitary operation on $$$N$$$ qubits which is represented by the following square matrix of size $$$2^N$$$:top right and bottom left quarters are filled with zero elements,top left quarter is an anti-diagonal matrix of size $$$2^{N-1}$$$,bottom right quarter is filled with non-zero elements.For example, for $$$N = 2$$$ the matrix of the operation should have the following shape:.X..X.....XX..XXHereXdenotes a \"non-zero\" element of the matrix (a complex number which has the square of the absolute value greater than or equal to $$$10^{-5}$$$), and.denotes a \"zero\" element of the matrix (a complex number which has the square of the absolute value less than $$$10^{-5}$$$).The row and column indices of the matrix follow little endian format: the least significant bit of the index is stored first in the qubit array. Thus, the first column of the matrix gives you the coefficients of the basis states you'll get if you apply the unitary to the $$$|00..0\\\\rangle$$$ basis state, the second column - to the $$$|10..0\\\\rangle$$$ basis state etc. You can use theDumpUnitary toolto get the coefficients of the matrix your unitary implements (up to relative phases between columns) and the corresponding pattern ofXs and.s.You have to implement an operation which takes an array of $$$N$$$ ($$$2 \\\\le N \\\\le 5$$$) qubits as an input and applies the unitary transformation with the matrix of the described shape to it. If there are multiple unitaries which satisfy the requirements, you can implement any of them. The \"output\" of your operation is the pattern of the matrix coefficients implemented by it; you can see the testing harness in theUnitaryPatternskata.Your code should have the following signature:namespace Solution {open Microsoft.Quantum.Primitive;open Microsoft.Quantum.Canon;operation Solve (qs : Qubit[]) : Unit {// your code here}}", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "d02ac65f", "template_md5": "35d339e4", "result": "You are given a number $N$ ($2 \\le N \\le 5$).  You need to write a program that performs a specific type of operation on $N$ qubits. \n\nThis operation is represented by a square matrix of size $2^N$. The matrix has the following structure:\n\n* The top right and bottom left quarters of the matrix are filled with zeros.\n* The top left quarter is a diagonal matrix of size $2^{N-1}$.\n* The bottom right quarter is filled with non-zero elements.\n\nThe non-zero elements are complex numbers where the square of the absolute value is greater than or equal to $10^{-5}$. The zeros are complex numbers where the square of the absolute value is less than $10^{-5}$.\n\nThe rows and columns of the matrix are indexed using little endian format. This means the least significant bit of the index is stored first.\n\nYour program should take an array of $N$ qubits as input and apply this matrix operation to them. The output of your program is the pattern of the matrix coefficients. \n\n\nYou can use a tool called \"DumpUnitary\" to help you understand the matrix structure and the pattern of zeros and non-zeros. \n\nYour program should have the following structure:\n\n```\nnamespace Solution {\n  open Microsoft.Quantum.Primitive;\n  open Microsoft.Quantum.Canon;\n  operation Solve (qs : Qubit[]) : Unit {\n    // your code here\n  }\n}\n```"}, {"prompt_md5": "e130213d", "template_md5": "465699a0", "result": "You are given a number N (between 2 and 5).  You need to write a program that takes N qubits as input and applies a specific type of transformation to them. This transformation is defined by a matrix with a particular pattern of zeros and non-zero values. The output of your program is the pattern of values in this matrix."}]}