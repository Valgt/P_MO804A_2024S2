{"uid": "1736-C2", "url": "https://codeforces.com/contest/1736/problem/C2", "tags": ["binary search", " data structures", " dp", " two pointers"], "title": "1736-C2", "statement": "C2. Good Subarrays (Hard Version)time limit per test3 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputThis is the hard version of this problem. In this version, we have queries. Note that we do not have multiple test cases in this version. You can make hacks only if both versions of the problem are solved.An array $$$b$$$ of length $$$m$$$ isgoodif for all $$$i$$$ the $$$i$$$-th element is greater than or equal to $$$i$$$. In other words, $$$b$$$ isgoodif and only if $$$b_i \\\\geq i$$$ for all $$$i$$$ ($$$1 \\\\leq i \\\\leq m$$$).You are given an array $$$a$$$ consisting of $$$n$$$ positive integers, and you are asked $$$q$$$ queries.In each query, you are given two integers $$$p$$$ and $$$x$$$ ($$$1 \\\\leq p,x \\\\leq n$$$). You have to do $$$a_p := x$$$ (assign $$$x$$$ to $$$a_p$$$). In the updated array, find the number of pairs of indices $$$(l, r)$$$, where $$$1 \\\\le l \\\\le r \\\\le n$$$, such that the array $$$[a_l, a_{l+1}, \\\\ldots, a_r]$$$ isgood.Note that all queries areindependent, which means after each query, the initial array $$$a$$$ is restored.InputThe first line contains a single integer $$$n$$$ ($$$1 \\\\le n \\\\le 2 \\\\cdot 10^5$$$).The second line contains $$$n$$$ integers $$$a_1, a_2, \\\\ldots, a_n$$$ ($$$1 \\\\le a_i \\\\le n$$$).The third line contains an integer $$$q$$$ ($$$1 \\\\leq q \\\\leq 2 \\\\cdot 10^5$$$) — the number of queries.Each of the next $$$q$$$ lines contains two integers $$$p_j$$$ and $$$x_j$$$ ($$$1 \\\\leq p_j, x_j \\\\leq n$$$) – the description of the $$$j$$$-th query.OutputFor each query, print the number of suitable pairs of indices after making the change.ExamplesInput4 2 4 1 4 3 2 4 3 3 2 1Output6 10 5Input5 1 1 3 2 1 3 1 3 2 5 4 5Output7 9 8NoteHere are notes for first example.In first query, after update $$$a=[2,4,1,4]$$$. Now $$$(1,1)$$$, $$$(2,2)$$$, $$$(3,3)$$$, $$$(4,4)$$$, $$$(1,2)$$$, and $$$(3,4)$$$ are suitable pairs.In second query, after update $$$a=[2,4,3,4]$$$. Now all subarrays of $$$a$$$ aregood.In third query, after update $$$a=[2,1,1,4]$$$. Now $$$(1,1)$$$, $$$(2,2)$$$, $$$(3,3)$$$, $$$(4,4)$$$, and $$$(3,4)$$$ are suitable.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "489e23aa", "template_md5": "35d339e4", "result": "You are given an array of $n$ positive integers. You will be asked $q$ queries. Each query consists of two integers $p$ and $x$.  You must update the $p$-th element of the array to $x$. After each update, you need to count the number of pairs of indices $(l, r)$ where $1 \\le l \\le r \\le n$ such that the subarray $a_l, a_{l+1}, ..., a_r$ is \"good\".\n\nAn array is \"good\" if for all $i$, the $i$-th element is greater than or equal to $i$.  \n\nNote that after each query, the array is reset to its original state."}, {"prompt_md5": "b604ac72", "template_md5": "465699a0", "result": "You are given a list of numbers. You will be asked to change some numbers in the list multiple times. After each change, count how many sublists within the list have all numbers greater than or equal to their position in the list."}]}