{"uid": "1968-F", "url": "https://codeforces.com/contest/1968/problem/F", "tags": ["binary search", " data structures"], "title": "1968-F", "statement": "F. Equal XOR Segmentstime limit per test5 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputLet us call an array $$$x_1,\\\\dots,x_m$$$ interesting if it is possible to divide the array into $$$k>1$$$ parts so thatbitwise XORof values from each part are equal.More formally, you must split array $$$x$$$ into $$$k$$$ consecutive segments, each element of $$$x$$$ must belong toexactly$$$1$$$ segment. Let $$$y_1,\\\\dots,y_k$$$ be the XOR of elements from each part respectively. Then $$$y_1=y_2=\\\\dots=y_k$$$ must be fulfilled.For example, if $$$x = [1, 1, 2, 3, 0]$$$, you can split it as follows: $$$[\\\\color{blue}1], [\\\\color{green}1], [\\\\color{red}2, \\\\color{red}3, \\\\color{red}0]$$$. Indeed $$$\\\\color{blue}1=\\\\color{green}1=\\\\color{red}2 \\\\oplus \\\\color{red}3\\\\oplus \\\\color{red}0$$$.You are given an array $$$a_1,\\\\dots,a_n$$$. Your task is to answer $$$q$$$ queries:For fixed $$$l$$$, $$$r$$$, determine whether the subarray $$$a_l,a_{l+1},\\\\dots,a_r$$$ is interesting.InputThe first line contains a single integer $$$t$$$ ($$$1\\\\le t\\\\le 10^4$$$) — the number of test cases.The first line of each test case contains two integers $$$n$$$ and $$$q$$$ ($$$2 \\\\le n \\\\le 2 \\\\cdot 10^5$$$, $$$1 \\\\le q \\\\le 2 \\\\cdot 10^5$$$) — the number of elements in the array and the number of queries respectively.The next line contains $$$n$$$ integers $$$a_1,\\\\dots,a_n$$$ ($$$0 \\\\le a_i < 2^{30}$$$) — elements of the array.Each of the next $$$q$$$ lines contains two integers $$$l$$$ and $$$r$$$ ($$$1 \\\\le l < r \\\\le n$$$) describing the query.It is guaranteed that the sum of $$$n$$$ over all testcases does not exceed $$$2 \\\\cdot 10^5$$$.It is guaranteed that the sum of $$$q$$$ over all testcases does not exceed $$$2 \\\\cdot 10^5$$$.OutputFor each query, output \"YES\" if the subarray is interesting and \"NO\" otherwise.You can output \"Yes\" and \"No\" in any case (for example, the strings \"yES\", \"yes\", and \"Yes\" will be recognized as correct answers).ExampleInput45 51 1 2 3 01 52 43 51 33 45 51 2 3 4 51 52 43 51 32 37 412 9 10 9 10 11 91 51 72 62 711 40 0 1 0 0 1 0 1 1 0 11 22 56 97 11OutputYES YES NO NO NO  YES NO NO YES NO  NO NO NO NO  YES NO YES YESNoteExplanation for the first test case:The first query is described in the statement.In the second query, we should divide $$$[1,2,3]$$$. A possible division is $$$[1,2],[3]$$$, since $$$1\\\\oplus 2=3$$$.It can be shown that for queries $$$3,4,5$$$, the subarrays are not interesting.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "334699f9", "template_md5": "35d339e4", "result": "You are given an array of integers.  You need to determine if you can divide the array into multiple parts such that the bitwise XOR of the elements in each part is equal.\n\n**Input:**\n\n*  The first line contains the number of test cases, *t*.\n*  For each test case:\n    * The first line contains two integers, *n* (the size of the array) and *q* (the number of queries).\n    * The next line contains *n* integers, the elements of the array.\n    * The next *q* lines each contain two integers, *l* and *r*, representing a query (a subarray from index *l* to *r* inclusive).\n\n**Output:**\n\nFor each query, output \"YES\" if the subarray is interesting (can be divided into parts with equal XOR sums) and \"NO\" otherwise."}, {"prompt_md5": "28a8a069", "template_md5": "465699a0", "result": "You are given a list of numbers.  For each sublist within the larger list, determine if you can divide the sublist into smaller parts where the sum of all the numbers in each part is the same."}]}