{"uid": "1437-D", "url": "https://codeforces.com/contest/1437/problem/D", "tags": ["graphs", " greedy", " shortest paths", " trees"], "title": "1437-D", "statement": "D. Minimal Height Treetime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputMonocarp had a tree which consisted of $$$n$$$ vertices and was rooted at vertex $$$1$$$. He decided to study BFS (Breadth-first search), so he ran BFS on his tree, starting from the root. BFS can be described by the following pseudocode:a = [] # the order in which vertices were processedq = Queue()q.put(1) # place the root at the end of the queuewhile not q.empty():k = q.pop() # retrieve the first vertex from the queuea.append(k) # append k to the end of the sequence in which vertices were visitedfor y in g[k]: # g[k] is the list of all children of vertex k, sorted in ascending orderq.put(y)Monocarp was fascinated by BFS so much that, in the end, he lost his tree. Fortunately, he still has a sequence of vertices, in which order vertices were visited by the BFS algorithm (the arrayafrom the pseudocode). Monocarp knows that each vertex was visited exactly once (since they were put and taken from the queue exactly once). Also, he knows that all children of each vertex were viewedin ascending order.Monocarp knows that there are many trees (in the general case) with the same visiting order $$$a$$$, so he doesn't hope to restore his tree. Monocarp is okay with any tree thathas minimum height.The heightof a tree is the maximum depth of the tree's vertices, and the depth of a vertex is the number of edges in the path from the root to it. For example, the depth of vertex $$$1$$$ is $$$0$$$, since it's the root, and the depth of all root's children are $$$1$$$.Help Monocarp to find any tree with given visiting order $$$a$$$ and minimum height.InputThe first line contains a single integer $$$t$$$ ($$$1 \\\\le t \\\\le 1000$$$) — the number of test cases.The first line of each test case contains a single integer $$$n$$$ ($$$2 \\\\le n \\\\le 2 \\\\cdot 10^5$$$) — the number of vertices in the tree.The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\\\dots, a_n$$$ ($$$1 \\\\le a_i \\\\le n$$$; $$$a_i \\\\neq a_j$$$; $$$a_1 = 1$$$) — the order in which the vertices were visited by the BFS algorithm.It's guaranteed that the total sum of $$$n$$$ over test cases doesn't exceed $$$2 \\\\cdot 10^5$$$.OutputFor each test case print the minimum possible height of a tree with the given visiting order $$$a$$$.ExampleInput3 4 1 4 3 2 2 1 2 3 1 2 3Output3 1 1NoteIn the first test case, there is only one tree with the given visiting order:In the second test case, there is only one tree with the given visiting order as well:In the third test case, an optimal tree with the given visiting order is shown below:", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "1e5bf110", "template_md5": "35d339e4", "result": "You are given a sequence of integers $a_1, a_2, ..., a_n$ representing the order in which vertices were visited by a Breadth-First Search (BFS) algorithm starting from vertex 1.  \n\nYou know that:\n\n*  $a_1 = 1$ (vertex 1 is the root)\n*  Each vertex is visited exactly once.\n*  Children of each vertex are visited in ascending order.\n\nYour task is to find the minimum possible height of a tree that has this visiting order. The height of a tree is the maximum depth of any vertex in the tree. The depth of a vertex is the number of edges on the path from the root to that vertex. \n\n\n\nLet me know if you'd like help with the algorithm to solve this problem!"}, {"prompt_md5": "6e877574", "template_md5": "465699a0", "result": "Given a list of integers representing the order in which nodes were visited in a breadth-first search, find the minimum possible height of a tree that could have produced this visit order."}]}