{"uid": "1366-B", "url": "https://codeforces.com/contest/1366/problem/B", "tags": ["math", " two pointers"], "title": "1366-B", "statement": "B. Shuffletime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputYou are given an array consisting of $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$. Initially $$$a_x = 1$$$, all other elements are equal to $$$0$$$.You have to perform $$$m$$$ operations. During the $$$i$$$-th operation, you choose two indices $$$c$$$ and $$$d$$$ such that $$$l_i \\\\le c, d \\\\le r_i$$$, and swap $$$a_c$$$ and $$$a_d$$$.Calculate the number of indices $$$k$$$ such that it is possible to choose the operations so that $$$a_k = 1$$$ in the end.InputThe first line contains a single integer $$$t$$$ ($$$1 \\\\le t \\\\le 100$$$) — the number of test cases. Then the description of $$$t$$$ testcases follow.The first line of each test case contains three integers $$$n$$$, $$$x$$$ and $$$m$$$ ($$$1 \\\\le n \\\\le 10^9$$$; $$$1 \\\\le m \\\\le 100$$$; $$$1 \\\\le x \\\\le n$$$).Each of next $$$m$$$ lines contains the descriptions of the operations; the $$$i$$$-th line contains two integers $$$l_i$$$ and $$$r_i$$$ ($$$1 \\\\le l_i \\\\le r_i \\\\le n$$$).OutputFor each test case print one integer — the number of indices $$$k$$$ such that it is possible to choose the operations so that $$$a_k = 1$$$ in the end.ExampleInput3 6 4 3 1 6 2 3 5 5 4 1 2 2 4 1 2 3 3 2 2 3 1 2Output6 2 3NoteIn the first test case, it is possible to achieve $$$a_k = 1$$$ for every $$$k$$$. To do so, you may use the following operations:swap $$$a_k$$$ and $$$a_4$$$;swap $$$a_2$$$ and $$$a_2$$$;swap $$$a_5$$$ and $$$a_5$$$.In the second test case, only $$$k = 1$$$ and $$$k = 2$$$ are possible answers. To achieve $$$a_1 = 1$$$, you have to swap $$$a_1$$$ and $$$a_1$$$ during the second operation. To achieve $$$a_2 = 1$$$, you have to swap $$$a_1$$$ and $$$a_2$$$ during the second operation.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "3126cd40", "template_md5": "35d339e4", "result": "You are given an array of $n$ integers. Initially, only the $x$-th element is 1, all other elements are 0. You can perform $m$ operations. In each operation, you choose two indices $c$ and $d$ such that $l_i \\le c, d \\le r_i$ and swap the elements at positions $c$ and $d$. \n\nDetermine the number of indices $k$ for which it is possible to make the element at index $k$ equal to 1 after performing some sequence of these operations. \n\n\n\nInput:\n\n* The first line contains an integer $t$ ($1 \\le t \\le 100$) representing the number of test cases.\n* For each test case:\n    * The first line contains three integers $n$, $x$, and $m$ ($1 \\le n \\le 10^9$; $1 \\le m \\le 100$; $1 \\le x \\le n$).\n    * The next $m$ lines each contain two integers $l_i$ and $r_i$ ($1 \\le l_i \\le r_i \\le n$).\n\nOutput:\n\nFor each test case, print a single integer representing the number of indices $k$ that can be made equal to 1."}, {"prompt_md5": "04ee24fa", "template_md5": "465699a0", "result": "You have an array of numbers. One number is initially 1, the rest are 0. You can swap any two numbers within a given range.  Find how many positions in the array can be made to have the value 1 after performing the swaps."}]}