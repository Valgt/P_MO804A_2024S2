{"uid": "1275-E3", "url": "https://codeforces.com/contest/1275/problem/E3", "tags": ["*special"], "title": "1275-E3", "statement": "E3. Контрольная суммаограничение по времени на тест2 секундыограничение по памяти на тест512 мегабайтвводстандартный вводвыводстандартный выводДанные пользователей ВКонтакте хранятся на десятках тысяч серверов. Для того, чтобы можно было определять ошибки при записи данных на диск, на диск регулярно записываются текущие контрольные суммы CRC32 (Wiki, IEEE 802-3). Благодаря этому, при чтении данных можно заново вычислить контрольную сумму и проверить, что данные и контрольная сумма записаны корректно.Разумеется, проверки на совпадение контрольной суммы встроены в большинство сервисов ВКонтакте. Но как-то раз оказалось, что в одном сегменте данных нужно изменить значение четырех последовательных байт на новое — нужно заменить значения последовательности $$$a_i, a_{i+1}, a_{i+2}, a_{i+3}$$$ на $$$x_0, x_1, x_2, x_3$$$. При этом, нужно чтобы значение контрольной суммы CRC32 осталось прежним. Конечно, при изменении последовательности ее контрольная сумма изменится, поэтому кроме изменения этих четырех байт на новое значение, были выбраны четыре байта $$$a_{j}, a_{j+1}, a_{j+2}, a_{j+3}$$$, которым можно назначить любое значение. Ваша задача выбрать им новые значения так, чтобы CRC32 данной последовательности не изменился, или определить, что это невозможно. Поскольку изменение данных — операция серьезная, перед самим изменением нужно определить, как изменится последовательность для $$$q$$$ независимых тестовых случаев.Входные данныеВ первой строке дано два целых числа $$$n$$$ и $$$q$$$ — количество байт в файле и количество запросов, для которых нужно решить задачу ($$$8 \\\\le n \\\\le 2 \\\\cdot 10^5$$$; $$$1 \\\\le q \\\\le 10^5$$$).Во второй строке дано $$$n$$$ чисел $$$a_0, a_1, \\\\ldots, a_{n-1}$$$ — содержимое файла в байтах ($$$0 \\\\le a_i \\\\le 255$$$).В следующих $$$q$$$ строках дано по шесть чисел $$$i, j, x_0, x_1, x_2, x_3$$$ — позиция $$$i$$$, начиная с которой нужно заменить четыре байта на $$$x_0, x_1, x_2, x_3$$$, и позиция $$$j$$$, начиная с которой можно менять четыре байта как угодно ($$$0 \\\\le i, j \\\\le n-4$$$; $$$0 \\\\le x_0, x_1, x_2, x_3 \\\\le 255$$$). Гарантируется, что отрезки $$$[i; i+3]$$$ и $$$[j; j+3]$$$ не пересекаются.Выходные данныеДля каждого запроса выведите четыре целых числа $$$z_0, z_1, z_2, z_3$$$, на которые нужно заменить четыре байта с номерами $$$j, j+1, j+2, j+3$$$, чтобы crc32 не изменился. Обратите внимание, что все запросы независимы, и на самом деле последовательность не изменяется.Если существует несколько решений, выведите любое, а если для данного запроса валидного решения нет, выведитеNo solution.ПримерыВходные данные8 1 1 2 3 4 5 6 7 8 0 4 0 0 0 0Выходные данные212 34 127 159Входные данные16 3 4 5 6 7 0 0 0 0 0 0 0 85 200 47 47 0 11 0 0 0 0 0 3 12 7 0 0 0 0 11 0 0 0 0Выходные данные0 0 0 0 200 47 47 0 0 0 0 0ПримечаниеCRC32байтовой последовательности из первого примера(1 2 3 4 5 6 7 8) равен3fca88c5, CRC32измененной последовательности(0 0 0 0 212 34 127 159) так же равен3fca88c5. Стандартная утилита crc32 из большинства дистрибутивов линукса должна посчитать от них данную контрольную сумму.CRC32 последовательности из второго примера равенecbb4b55.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "1ffa9728", "template_md5": "35d339e4", "result": "You are given a sequence of 8 bytes. You need to replace 4 consecutive bytes in the sequence with 4 new bytes.  You also have another 4 bytes in the sequence that you can change to any value.  \n\nYour goal is to find 4 new values for the second set of bytes so that the CRC32 checksum of the entire sequence remains the same. \n\n**Input:**\n\n*  The first line contains two integers, *n* (the number of bytes) and *q* (the number of queries).\n*  The second line contains *n* integers, representing the initial bytes of the sequence.\n*  Each of the next *q* lines contains six integers: *i*, *j*, *x0*, *x1*, *x2*, *x3*. \n    * *i* is the starting position of the 4 bytes to be replaced.\n    * *j* is the starting position of the 4 bytes that can be changed.\n    * *x0*, *x1*, *x2*, *x3* are the new values for the first 4 bytes.\n\n**Output:**\n\nFor each query, output four integers *z0*, *z1*, *z2*, *z3*, representing the new values for the second set of 4 bytes. If no solution exists, output \"No solution\"."}, {"prompt_md5": "836d0c9e", "template_md5": "465699a0", "result": "You are given a sequence of bytes. You need to change four bytes in a specific location within the sequence to new values. You are also allowed to change four other bytes in a different location.  Find values for the four bytes you are allowed to change so that the overall checksum (CRC32) of the sequence remains the same. If no such values exist, say so."}]}