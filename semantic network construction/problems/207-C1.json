{"uid": "207-C1", "url": "https://codeforces.com/contest/207/problem/C1", "tags": [], "title": "207-C1", "statement": "C1. Game with Two Treestime limit per test1 secondmemory limit per test256 megabytesinputstdinoutputstdoutThe Smart Beaver from ABBYY has come up with a new developing game for children. The Beaver thinks that this game will help children to understand programming better.The main object of the game is finite rooted trees, each of their edges contains some lowercase English letter. Vertices on any tree are always numbered sequentially from1tom, wheremis the number of vertices in the tree. Before describing the actual game, let's introduce some definitions.We'll assume that the sequence of vertices with numbersv1,v2,...,vk(k≥ 1) is aforward path, if for any integerifrom1tok- 1vertexviis a direct ancestor of vertexvi+ 1. If we sequentially write out all letters from the the edges of the given path fromv1tovk, we get some string (k= 1gives us an empty string). We'll say that such string corresponds to forward pathv1,v2,...,vk.We'll assume that the sequence of tree vertices with numbersv1,v2,...,vk(k≥ 1) is abackward pathif for any integerifrom1tok- 1vertexviis the direct descendant of vertexvi+ 1. If we sequentially write out all the letters from the edges of the given path fromv1tovk, we get some string (k= 1gives us an empty string). We'll say that such string corresponds to backward pathv1,v2,...,vk.Now let's describe the game that the Smart Beaver from ABBYY has come up with. The game uses two rooted trees, each of which initially consists of one vertex with number1. The player is given some sequence of operations. Each operation is characterized by three values (t,v,c) where:tis the number of the tree on which the operation is executed (1or2);vis the vertex index in this tree (it is guaranteed that the tree contains a vertex with this index);cis a lowercase English letter.The actual operation is as follows: vertexvof treetgets a new descendant with numberm+ 1(wheremis the current number of vertices in treet), and there should be lettercput on the new edge from vertexvto vertexm+ 1.We'll say that an ordered group of three integers (i,j,q) is agood combinationif:1 ≤i≤m1, wherem1is the number of vertices in the first tree;1 ≤j,q≤m2, wherem2is the number of vertices in the second tree;there exists a forward pathv1,v2,...,vksuch thatv1=jandvk=qin the second tree;the string that corresponds to the forward path in the second tree from vertexjto vertexqequals the string that corresponds to the backward path in the first tree from vertexito vertex1(note that both paths are determined uniquely).Your task is to calculate the number of existing good combinations after each operation on the trees.InputThe first line contains integern— the number of operations on the trees. Nextnlines specify the operations in the order of their execution. Each line has form \"tvc\", wheretis the number of the tree,vis the vertex index in this tree, andcis a lowercase English letter.To get the full points for the first group of tests it is sufficient to solve the problem with1 ≤n≤ 700.To get the full points for the second group of tests it is sufficient to solve the problem with1 ≤n≤ 7000.To get the full points for the third group of tests it is sufficient to solve the problem with1 ≤n≤ 100000.OutputPrint exactlynlines, each containing one integer — the number of existing good combinations after the corresponding operation from the input.Please, do not use the%lldspecifier to read or write 64-bit integers in С++. It is preferred to use thecin,coutstreams or the%I64dspecifier.ExamplesInput51 1 a2 1 a1 2 b2 1 b2 3 aOutput13347NoteAfter the first operation the only good combination was(1, 1, 1). After the second operation new good combinations appeared,(2, 1, 2)and(1, 2, 2). The third operation didn't bring any good combinations. The fourth operation added good combination(1, 3, 3). Finally, the fifth operation resulted in as much as three new good combinations —(1, 4, 4),(2, 3, 4)and(3, 1, 4).", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "6a652f3e", "template_md5": "35d339e4", "result": "You are given two trees, each initially containing only one vertex (vertex 1).  You will be given a sequence of operations. Each operation consists of:\n\n*  A tree number (1 or 2)\n*  A vertex index (v) in that tree\n*  A lowercase English letter (c)\n\nEach operation adds a new vertex (numbered m+1, where m is the current number of vertices in the tree) as a descendant of vertex v, and places letter c on the edge between v and the new vertex.\n\nA \"good combination\" is a set of three integers (i, j, q) where:\n\n*  1 ≤ i ≤ m1 (m1 is the number of vertices in the first tree)\n*  1 ≤ j, q ≤ m2 (m2 is the number of vertices in the second tree)\n*  There exists a forward path v1, v2, ..., vk in the second tree such that v1 = j and vk = q.\n*  The string of letters along the forward path from j to q in the second tree is the same as the string of letters along the backward path from i to 1 in the first tree.\n\nFor each operation, determine the number of existing good combinations.\n\n\n\nLet me know if you'd like me to elaborate on any part of the problem!"}, {"prompt_md5": "251587f3", "template_md5": "465699a0", "result": "You are given two trees, each initially with one vertex.  You perform operations that add a new vertex as a child to an existing vertex, and assign a letter to the edge connecting them.  After each operation, count the number of pairs of vertices in the trees that satisfy these conditions:\n\n* One vertex is in the first tree and the other is in the second tree.\n* There is a path from the second tree vertex to the first tree vertex that matches the letters on the edges in reverse order."}]}