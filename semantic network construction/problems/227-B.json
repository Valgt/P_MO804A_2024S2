{"uid": "227-B", "url": "https://codeforces.com/contest/227/problem/B", "tags": ["implementation"], "title": "227-B", "statement": "B. Effective Approachtime limit per test2 secondsmemory limit per test256 megabytesinputstdinoutputstdoutOnce at a team training Vasya, Petya and Sasha got a problem on implementing linear search in an array.According to the boys, linear search works as follows. The array elements in a pre-selected order are in turn compared with the number that you need to find. Once you find the array element that is equal to the required one, the search ends. The efficiency of the algorithm is the number of performed comparisons. The fewer comparisons the linear search has made, the more effective it is.Vasya believes that a linear search would work better if it sequentially iterates through the elements, starting with the1-st one (in this problem we consider the elements of the array indexed from1ton) and ending with then-th one. And Petya says that Vasya is wrong: the search will need less comparisons if it sequentially iterates the elements starting from then-th and ending with the1-st one. Sasha argues that the two approaches are equivalent.To finally begin the task, the teammates decided to settle the debate and compare the two approaches on an example. For this, they took an array that is a permutation of integers from1ton, and generatedmqueries of the form: find element with valuebiin the array. They want to calculate for both approaches how many comparisons in total the linear search will need to respond to all queries. If the first search needs fewer comparisons, then the winner of the dispute is Vasya. If the second one does, then the winner is Petya. If both approaches make the same number of comparisons, then Sasha's got the upper hand.But the problem is, linear search is too slow. That's why the boys aren't going to find out who is right before the end of the training, unless you come in here. Help them to determine who will win the dispute.InputThe first line contains integern(1 ≤n≤ 105)— the number of elements in the array. The second line containsndistinct space-separated integersa1,a2, ...,an(1 ≤ai≤n)— the elements of array.The third line contains integerm(1 ≤m≤ 105)— the number of queries. The last line containsmspace-separated integersb1,b2, ...,bm(1 ≤bi≤n)— the search queries. Note that the queries can repeat.OutputPrint two integers, showing how many comparisons Vasya's approach needs and how many comparisons Petya's approach needs. Separate the numbers by spaces.Please, do not use the%lldspecifier to read or write 64-bit integers in С++. It is preferred to usecin,coutstreams or the%I64dspecifier.ExamplesInput21 211Output1 2Input22 111Output2 1Input33 1 231 2 3Output6 6NoteIn the first sample Vasya's approach will make one comparison (it starts with the1-st element and immediately finds the required number), and Petya's approach makes two comparisons (first he compares with the2-nd array element, doesn't find the search item and compares with the1-st element).In the second sample, on the contrary, Vasya's approach will need two comparisons (first with1-st element, and then with the2-nd), and Petya's approach will find the required value in one comparison (the first comparison with the2-nd element).", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "2a8d932d", "template_md5": "35d339e4", "result": "You are given an array of $n$ distinct integers from 1 to $n$.  There are $m$ queries, each asking for the index of a specific integer $b_i$ in the array.\n\nThere are two ways to search for each $b_i$:\n\n1. **Approach 1:** Start at the first element of the array and sequentially check each element until you find $b_i$ or reach the end of the array.\n\n2. **Approach 2:** Start at the last element of the array and sequentially check each element until you find $b_i$ or reach the beginning of the array.\n\nFor each query, count the number of comparisons made by each approach.  Calculate the total number of comparisons for all queries for both approaches. Determine which approach makes fewer comparisons in total. \n\nOutput the total number of comparisons for each approach separated by a space."}, {"prompt_md5": "5eff469c", "template_md5": "465699a0", "result": "You are given a list of numbers and a set of target numbers.  There are two ways to search for a target number in the list:\n\n1. Start at the beginning of the list and check each number in order.\n2. Start at the end of the list and check each number in order.\n\nFor each target number, count the number of comparisons needed for each search method.  Determine which method requires fewer total comparisons across all target numbers."}]}