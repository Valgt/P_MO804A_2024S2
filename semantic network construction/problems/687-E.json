{"uid": "687-E", "url": "https://codeforces.com/contest/687/problem/E", "tags": ["dfs and similar", " graphs"], "title": "687-E", "statement": "E. TOFtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputToday Pari gave Arya a cool graph problem. Arya wrote a non-optimal solution for it, because he believes in his ability to optimize non-optimal solutions. In addition to being non-optimal, his code was buggy and he tried a lot to optimize it, so the code also became dirty! He keeps getting Time Limit Exceeds and he is disappointed. Suddenly a bright idea came to his mind!Here is how his dirty code looks like:dfs(v){set count[v] = count[v] + 1if(count[v] < 1000){foreach u in neighbors[v]{if(visited[u] is equal to false){dfs(u)}break}}set visited[v] = true}main(){input the digraph()TOF()foreach 1<=i<=n{set count[i] = 0 , visited[i] = false}foreach 1 <= v <= n{if(visited[v] is equal to false){dfs(v)}}... // And do something cool and magical but we can't tell you what!}He asks you to write theTOFfunction in order to optimize the running time of the code with minimizing the number of calls of thedfsfunction. The input is a directed graph and in theTOFfunction you have to rearrange the edges of the graph in the listneighborsfor each vertex. The number of calls ofdfsfunction depends on the arrangement ofneighborsof each vertex.InputThe first line of the input contains two integersnandm(1 ≤n,m≤ 5000) — the number of vertices and then number of directed edges in the input graph.Each of the nextmlines contains a pair of integersuiandvi(1  ≤ui,vi≤n), meaning there is a directededge in the input graph.You may assume that the graph won't contain any self-loops and there is at most one edge between any unordered pair of vertices.OutputPrint a single integer — the minimum possible number ofdfscalls that can be achieved with permuting the edges.ExamplesInput3 31 22 33 1Output2998Input6 71 22 33 13 44 55 66 4Output3001", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "4bd5fcd6", "template_md5": "35d339e4", "result": "You are given a directed graph with $n$ vertices and $m$ edges.  The edges are represented as pairs of integers $(u, v)$ where there is a directed edge from vertex $u$ to vertex $v$.\n\nYour task is to determine the minimum number of times the following function, `dfs`, needs to be called to traverse all vertices in the graph:\n\n```\ndfs(v) {\n  count[v] = count[v] + 1\n  if (count[v] < 1000) {\n    for each neighbor u of v {\n      if (visited[u] is false) {\n        dfs(u)\n        break\n      }\n    }\n  }\n  visited[v] = true\n}\n```\n\nThe `dfs` function works as follows:\n\n1. It increments a counter `count[v]` for the current vertex `v`.\n2. If `count[v]` is less than 1000, it iterates through the neighbors of `v`.\n3. For each unvisited neighbor `u`, it recursively calls `dfs(u)` and then breaks the loop.\n4. Finally, it marks `v` as visited.\n\nYou can modify the order of the edges listed in the `neighbors` list for each vertex to potentially reduce the number of `dfs` calls. \n\n**Input:**\n\n* The first line contains two integers $n$ and $m$ ($1 \\le n, m \\le 5000$), representing the number of vertices and edges, respectively.\n* The next $m$ lines each contain two integers $u$ and $v$ ($1 \\le u, v \\le n$), representing a directed edge from vertex $u$ to vertex $v$.\n\n**Output:**\n\n* Print a single integer representing the minimum number of `dfs` calls required."}, {"prompt_md5": "3a0927e1", "template_md5": "465699a0", "result": "You are given a directed graph.  Rearrange the edges connected to each vertex in a way that minimizes the number of times a depth-first search (DFS) algorithm needs to be run on the graph.  The goal is to find the smallest possible number of DFS calls."}]}