{"uid": "1990-E1", "url": "https://codeforces.com/contest/1990/problem/E1", "tags": ["binary search", " data structures", " dfs and similar", " interactive", " trees"], "title": "1990-E1", "statement": "E1. Catch the Mole(Easy Version)time limit per test4 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputThis is the easy version of the problem. The only difference is the limit on the number of queries.This is an interactive problem.You are given a tree of $$$n$$$ nodes with node $$$1$$$ as its root node.There is a hidden mole in one of the nodes. To find its position, you can pick an integer $$$x$$$ ($$$1 \\\\le x \\\\le n$$$) to make an inquiry to the jury. Next, the jury will return $$$1$$$ when the mole is in subtree $$$x$$$. Otherwise, the judge will return $$$0$$$. If the judge returns $$$0$$$ and the mole is not in root node $$$1$$$, the mole will move to the parent node of the node it is currently on.Use at most $$$300$$$ operations to find thecurrentnode where the mole is located.InputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\\\le t \\\\le 100$$$). The description of the test cases follows.InteractionThe first line of each test case contains one integer $$$n$$$ ($$$2 \\\\le n \\\\le 5000$$$).The following $$$n-1$$$ lines describe the edges of the tree. Each line contains two space-separated integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\\\le u_i, v_i \\\\le n$$$), indicating an edge between nodes $$$u_i$$$ and $$$v_i$$$.It is guaranteed that the input data represents a tree.The interactor in this task isnot adaptive. In other words, the node where the mole is located at first is fixed in every test case and does not change during the interaction.To ask a query, you need to pick a vertex $$$x$$$ ($$$1 \\\\le x \\\\le n$$$) and print the line of the following form:\"? x\"After that, you receive:$$$0$$$ if the mole is not in subtree $$$x$$$;$$$1$$$ if the mole is in subtree $$$x$$$.You can make at most $$$300$$$ queries of this form for each test case.Next, if your program has found thecurrentnode where the mole is located, print the line of the following form:\"! x\"Note that this line isnotconsidered a query and isnottaken into account when counting the number of queries asked.After this, proceed to the next test case.If you make more than $$$300$$$ queries during an interaction, your program must terminate immediately, and you will receive theWrong Answerverdict. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.After printing a query or the answer for a test case, do not forget to output the end of line and flush the output. Otherwise, you will get the verdictIdleness Limit Exceeded. To do this, use:fflush(stdout)orcout.flush()in C++;System.out.flush()in Java;flush(output)in Pascal;stdout.flush()in Python;see the documentation for other languages.HacksTo hack, follow the test format below.The first line contains the number of test cases $$$t$$$ ($$$1 \\\\le t \\\\le 100$$$). The description of the test cases follows.The first line of each test case contains two integers $$$n$$$ and $$$x$$$ ($$$2 \\\\le n \\\\le 5000$$$, $$$1 \\\\le x \\\\le n$$$) — the size of the tree and the initial position of the mole.The following $$$n-1$$$ lines describe the edges of the tree. Each line contains two space-separated integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\\\le u_i, v_i \\\\le n$$$), indicating an edge between nodes $$$u_i$$$ and $$$v_i$$$.The input data must represent a tree.ExampleInput2 2 1 2  1  6 1 2 1 3 1 4 4 5 5 6  0  0  1Output? 2  ! 2       ? 2  ? 6  ? 4  ! 4NoteIn the first test case, the mole is in node $$$2$$$ initially.For the query \"? 2\", the jury returns $$$1$$$ because the mole is in subtree $$$2$$$. After this query, the mole does not move.The answer $$$2$$$ is thecurrentnode where the mole is located, so the answer is considered correct.In the second test case, the mole is in node $$$6$$$ initially.For the query \"? 2\", the jury returns $$$0$$$ because the mole is not in subtree $$$2$$$. After this query, the mole moves from node $$$6$$$ to node $$$5$$$.For the query \"? 6\", the jury returns $$$0$$$ because the mole is not in subtree $$$6$$$. After this query, the mole moves from node $$$5$$$ to node $$$4$$$.For the query \"? 4\", the jury returns $$$1$$$ because the mole is in subtree $$$4$$$. After this query, the mole does not move.The answer $$$4$$$ is thecurrentnode where the mole is located, so the answer is considered correct.Please note that the example is only for understanding the statement, and the queries in the example donotguarantee to determine the unique position of the mole.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "78c81f36", "template_md5": "35d339e4", "result": "You are given a tree with $n$ nodes, where node 1 is the root. There is a hidden mole in one of the nodes. You can ask queries to find the mole's location.\n\n**Query:**\n\nYou choose a node $x$ and ask if the mole is in the subtree rooted at $x$. The answer is 1 if the mole is in the subtree, and 0 otherwise.\n\n**Mole Movement:**\n\nIf the mole is not in the subtree of the chosen node and the chosen node is not the root, the mole moves to the parent node of the chosen node.\n\n**Goal:**\n\nFind the node containing the mole using at most 300 queries.\n\n**Input:**\n\n* The number of test cases $t$.\n* For each test case:\n    * The number of nodes $n$.\n    * $n-1$ lines describing the edges of the tree (each line contains two nodes connected by an edge).\n\n**Output:**\n\n* For each test case:\n    * Print a query in the format \"? x\" where $x$ is the node you want to query.\n    * When you find the mole's location, print \"! x\" where $x$ is the node containing the mole.\n\n\n\n**Constraints:**\n\n* $2 \\le n \\le 5000$\n* $1 \\le t \\le 100$\n* You must use at most 300 queries per test case."}, {"prompt_md5": "4e5c8f99", "template_md5": "465699a0", "result": "You are given a tree with a hidden node. You can ask questions about whether a given node is in the subtree containing the hidden node. You have 300 questions to find the hidden node."}]}