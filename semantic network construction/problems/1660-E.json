{"uid": "1660-E", "url": "https://codeforces.com/contest/1660/problem/E", "tags": ["brute force", " constructive algorithms", " greedy", " implementation"], "title": "1660-E", "statement": "E. Matrix and Shiftstime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputYou are given a binary matrix $$$A$$$ of size $$$n \\\\times n$$$. Rows are numbered from top to bottom from $$$1$$$ to $$$n$$$, columns are numbered from left to right from $$$1$$$ to $$$n$$$. The element located at the intersection of row $$$i$$$ and column $$$j$$$ is called $$$A_{ij}$$$. Consider a set of $$$4$$$ operations:Cyclically shift all rows up. The row with index $$$i$$$ will be written in place of the row $$$i-1$$$ ($$$2 \\\\le i \\\\le n$$$), the row with index $$$1$$$ will be written in place of the row $$$n$$$.Cyclically shift all rows down. The row with index $$$i$$$ will be written in place of the row $$$i+1$$$ ($$$1 \\\\le i \\\\le n - 1$$$), the row with index $$$n$$$ will be written in place of the row $$$1$$$.Cyclically shift all columns to the left. The column with index $$$j$$$ will be written in place of the column $$$j-1$$$ ($$$2 \\\\le j \\\\le n$$$), the column with index $$$1$$$ will be written in place of the column $$$n$$$.Cyclically shift all columns to the right. The column with index $$$j$$$ will be written in place of the column $$$j+1$$$ ($$$1 \\\\le j \\\\le n - 1$$$), the column with index $$$n$$$ will be written in place of the column $$$1$$$.The $$$3 \\\\times 3$$$ matrix is shown on the left before the $$$3$$$-rd operation is applied to it, on the right — after.You can perform an arbitrary (possibly zero) number of operations on the matrix; the operations can be performed in any order.After that, you can perform an arbitrary (possibly zero) number of new xor-operations:Select any element $$$A_{ij}$$$ and assign it with new value $$$A_{ij} \\\\oplus 1$$$. In other words, the value of $$$(A_{ij} + 1) \\\\bmod 2$$$ will have to be written into element $$$A_{ij}$$$.Each application of this xor-operation costs one burl. Note that the $$$4$$$ shift operations — are free. These $$$4$$$ operations can only be performed before xor-operations are performed.Output the minimum number of burles you would have to pay to make the $$$A$$$ matrix unitary. Aunitary matrixis a matrix with ones on the main diagonal and the rest of its elements are zeros (that is, $$$A_{ij} = 1$$$ if $$$i = j$$$ and $$$A_{ij} = 0$$$ otherwise).InputThe first line of the input contains an integer $$$t$$$ ($$$1 \\\\le t \\\\le 10^4$$$) —the number of test cases in the test.The descriptions of the test cases follow. Before each test case, an empty line is written in the input.The first line of each test case contains a single number $$$n$$$ ($$$1 \\\\le n \\\\le 2000$$$)This is followed by $$$n$$$ lines, each containing exactly $$$n$$$ characters and consisting only of zeros and ones. These lines describe the values in the elements of the matrix.It is guaranteed that the sum of $$$n^2$$$ values over all test cases does not exceed $$$4 \\\\cdot 10^6$$$.OutputFor each test case, output the minimum number of burles you would have to pay to make the $$$A$$$ matrix unitary. In other words, print the minimum number of xor-operations it will take after applying cyclic shifts to the matrix for the $$$A$$$ matrix to become unitary.ExampleInput43010011100500010000011000001000001002101041111101111111111Output1 0 2 11NoteIn the first test case, you can do the following: first, shift all the rows down cyclically, then the main diagonal of the matrix will contain only \"1\". Then it will be necessary to apply xor-operation to the only \"1\" that is not on the main diagonal.In the second test case, you can make a unitary matrix by applying the operation $$$2$$$ — cyclic shift of rows upward twice to the matrix.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "4ad5eece", "template_md5": "35d339e4", "result": "You are given a square matrix of 0s and 1s. You can perform the following operations:\n\n* **Shift rows up:** Move each row up one position, wrapping the last row to the top.\n* **Shift rows down:** Move each row down one position, wrapping the first row to the bottom.\n* **Shift columns left:** Move each column left one position, wrapping the last column to the left.\n* **Shift columns right:** Move each column right one position, wrapping the first column to the right.\n\nYou can perform these shift operations any number of times in any order.  Afterward, you can perform XOR operations on individual elements of the matrix. An XOR operation on an element flips its value (0 becomes 1, 1 becomes 0). Each XOR operation costs one \"burl\".\n\nYour goal is to transform the matrix into a unitary matrix (a matrix with 1s on the diagonal and 0s everywhere else) using the minimum number of burls. \n\nInput:\n\n* The first line contains the number of test cases.\n* Each test case starts with a line containing the size of the matrix (n).\n* The following n lines contain the matrix elements (0s and 1s).\n\nOutput:\n\n* For each test case, output the minimum number of burls required to make the matrix unitary."}, {"prompt_md5": "663c5c46", "template_md5": "465699a0", "result": "You are given a square grid of 0s and 1s. You can perform four types of free operations: shift all rows up, shift all rows down, shift all columns left, shift all columns right. After these free operations, you can change any 0 to a 1 by paying one \"burle\". What is the minimum number of burles needed to make the grid a diagonal matrix (where only the main diagonal has 1s)?"}]}