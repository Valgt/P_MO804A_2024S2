{"uid": "1933-D", "url": "https://codeforces.com/contest/1933/problem/D", "tags": ["constructive algorithms", " greedy", " math", " number theory", " sortings"], "title": "1933-D", "statement": "D. Turtle Tenacity: Continual Modstime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputGiven an array $$$a_1, a_2, \\\\ldots, a_n$$$, determine whether it is possible torearrange its elementsinto $$$b_1, b_2, \\\\ldots, b_n$$$, such that $$$b_1 \\\\bmod b_2 \\\\bmod \\\\ldots \\\\bmod b_n \\\\neq 0$$$.Here $$$x \\\\bmod y$$$ denotes the remainder from dividing $$$x$$$ by $$$y$$$. Also, the modulo operations are calculated from left to right. That is, $$$x \\\\bmod y \\\\bmod z = (x \\\\bmod y) \\\\bmod z$$$. For example, $$$2024 \\\\bmod 1000 \\\\bmod 8 = (2024 \\\\bmod 1000) \\\\bmod 8 = 24 \\\\bmod 8 = 0$$$.InputThe first line of the input contains a single integer $$$t$$$ ($$$1 \\\\le t \\\\le 10^4$$$) — the number of test cases.The first line of each test case contains a single integer $$$n$$$ ($$$2 \\\\le n \\\\le 10^5$$$).The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\\\ldots, a_n$$$ ($$$1 \\\\le a_i \\\\le 10^9$$$).The sum of $$$n$$$ over all test cases does not exceed $$$2 \\\\cdot 10^5$$$.OutputFor each test case, output \"YES\" if it is possible, \"NO\" otherwise.You can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.ExampleInput861 2 3 4 5 653 3 3 3 332 2 351 1 2 3 731 2 231 1 265 2 10 10 10 243 6 9 3OutputYES NO YES NO YES NO YES NONoteIn the first test case, rearranging the array into $$$b = [1, 2, 3, 4, 5, 6]$$$ (doing nothing) would result in $$$1 \\\\bmod 2 \\\\bmod 3 \\\\bmod 4 \\\\bmod 5 \\\\bmod 6 = 1$$$. Hence it is possible to achieve the goal.In the second test case, the array $$$b$$$ must be equal to $$$[3, 3, 3, 3, 3]$$$, which would result in $$$3 \\\\bmod 3 \\\\bmod 3 \\\\bmod 3 \\\\bmod 3 = 0$$$. Hence it is impossible to achieve the goal.In the third test case, rearranging the array into $$$b = [3, 2, 2]$$$ would result in $$$3 \\\\bmod 2 \\\\bmod 2 = 1$$$. Hence it is possible to achieve the goal.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "89790d88", "template_md5": "35d339e4", "result": "Given an array of integers $a_1, a_2, ..., a_n$, determine if it's possible to rearrange the elements into a new array $b_1, b_2, ..., b_n$ such that:\n\n $$b_1 \\bmod b_2 \\bmod ... \\bmod b_n \\neq 0$$\n\nHere, $x \\bmod y$ represents the remainder when $x$ is divided by $y$. The modulo operations are performed from left to right. \n\nFor example:\n\n$$2024 \\bmod 1000 \\bmod 8 = (2024 \\bmod 1000) \\bmod 8 = 24 \\bmod 8 = 0$$\n\nInput:\n\n* The first line contains the number of test cases, $t$.\n* Each test case has two lines:\n    * The first line contains the size of the array, $n$.\n    * The second line contains $n$ integers, $a_1, a_2, ..., a_n$.\n\nOutput:\n\nFor each test case, print \"YES\" if it's possible to rearrange the array to satisfy the condition, otherwise print \"NO\"."}, {"prompt_md5": "1f46014f", "template_md5": "465699a0", "result": "Given a list of numbers, can you rearrange them so that the result of repeatedly taking remainders (modulo) from left to right is not zero?"}]}