{"uid": "1843-E", "url": "https://codeforces.com/contest/1843/problem/E", "tags": ["binary search", " brute force", " data structures", " two pointers"], "title": "1843-E", "statement": "E. Tracking Segmentstime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputYou are given an array $$$a$$$ consisting of $$$n$$$ zeros. You are also given a set of $$$m$$$ not necessarily different segments. Each segment is defined by two numbers $$$l_i$$$ and $$$r_i$$$ ($$$1 \\\\le l_i \\\\le r_i \\\\le n$$$) and represents a subarray $$$a_{l_i}, a_{l_i+1}, \\\\dots, a_{r_i}$$$ of the array $$$a$$$.Let's call the segment $$$l_i, r_i$$$beautifulif the number of ones on this segmentis strictly greaterthan the number of zeros. For example, if $$$a = [1, 0, 1, 0, 1]$$$, then the segment $$$[1, 5]$$$ isbeautiful(the number of ones is $$$3$$$, the number of zeros is $$$2$$$), but the segment $$$[3, 4]$$$ is not isbeautiful(the number of ones is $$$1$$$, the number of zeros is $$$1$$$).You also have $$$q$$$ changes. For each change you are given the number $$$1 \\\\le x \\\\le n$$$, which means that you must assign an element $$$a_x$$$ the value $$$1$$$.You have to find the first change after whichat least oneof $$$m$$$ given segments becomesbeautiful, or report that none of them is beautiful after processing all $$$q$$$ changes.InputThe first line contains a single integer $$$t$$$ ($$$1 \\\\le t \\\\le 10^4$$$) — the number of test cases.The first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\\\le m \\\\le n \\\\le 10^5$$$) — the size of the array $$$a$$$ and the number of segments, respectively.Then there are $$$m$$$ lines consisting of two numbers $$$l_i$$$ and $$$r_i$$$ ($$$1 \\\\le l_i \\\\le r_i \\\\le n$$$) —the boundaries of the segments.The next line contains an integer $$$q$$$ ($$$1 \\\\le q \\\\le n$$$) — the number of changes.The following $$$q$$$ lines each contain a single integer $$$x$$$ ($$$1 \\\\le x \\\\le n$$$) — the index of the array element that needs to be set to $$$1$$$. It is guaranteed that indexes in queries are distinct.It is guaranteed that the sum of $$$n$$$ for all test cases does not exceed $$$10^5$$$.OutputFor each test case, output one integer  — the minimum change number after which at least one of the segments will be beautiful, or $$$-1$$$ if none of the segments will be beautiful.ExampleInput65 51 24 51 51 32 45531244 21 14 42235 21 51 5421345 21 51 35412355 51 51 51 51 51 431433 22 21 33231Output3 -1 3 3 3 1NoteIn the first case, after first 2 changes we won't have any beautiful segments, but after the third one on a segment $$$[1; 5]$$$ there will be 3 ones and only 2 zeros, so the answer is 3.In the second case, there won't be any beautiful segments.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "529e2210", "template_md5": "465699a0", "result": "You have an array of zeros. You are given some ranges within the array.  You can change some zeros to ones. Find the minimum number of changes needed so that at least one of the ranges has more ones than zeros. If this is never possible, output -1."}, {"prompt_md5": "c3b60901", "template_md5": "35d339e4", "result": "You are given an array of $n$ zeros. You also have $m$ segments defined by their starting and ending indices ($l_i$ and $r_i$) within the array.  A segment is considered \"beautiful\" if it contains more ones than zeros.\n\nYou will perform $q$ changes, each changing a specific index in the array to a one.  \n\nYour task is to find the minimum number of changes required to make at least one of the given segments \"beautiful\". If no segment can ever become beautiful, output -1."}]}