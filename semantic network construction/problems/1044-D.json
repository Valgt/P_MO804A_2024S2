{"uid": "1044-D", "url": "https://codeforces.com/contest/1044/problem/D", "tags": ["data structures", " dsu"], "title": "1044-D", "statement": "D. Deduction Queriestime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputThere is an array $$$a$$$ of $$$2^{30}$$$ integers, indexed from $$$0$$$ to $$$2^{30}-1$$$. Initially, you know that $$$0 \\\\leq a_i < 2^{30}$$$ ($$$0 \\\\leq i < 2^{30}$$$), but you do not know any of the values. Your task is to process queries of two types:1 l r x: You are informed that thebitwise xorof the subarray $$$[l, r]$$$ (ends inclusive) is equal to $$$x$$$. That is, $$$a_l \\\\oplus a_{l+1} \\\\oplus \\\\ldots \\\\oplus a_{r-1} \\\\oplus a_r = x$$$, where $$$\\\\oplus$$$ is the bitwise xor operator. In some cases, the received update contradicts past updates. In this case, you shouldignorethe contradicting update (the current update).2 l r: You are asked to output the bitwise xor of the subarray $$$[l, r]$$$ (ends inclusive). If it is still impossible to know this value, considering all past updates, then output$$$-1$$$.Note that the queries areencoded. That is, you need to write anonlinesolution.InputThe first line contains a single integer $$$q$$$ ($$$1 \\\\leq q \\\\leq 2 \\\\cdot 10^5$$$) — the number of queries.Each of the next $$$q$$$ lines describes a query. It contains one integer $$$t$$$ ($$$1 \\\\leq t \\\\leq 2$$$) — the type of query.The given queries will beencodedin the following way: let $$$last$$$ be the answer to the last query of the second type that you have answered (initially, $$$last = 0$$$). If the last answer was $$$-1$$$, set $$$last = 1$$$.If $$$t = 1$$$, three integers follow, $$$l'$$$, $$$r'$$$, and $$$x'$$$ ($$$0 \\\\leq l', r', x' < 2^{30}$$$), meaning that you got an update.First, do the following:$$$l = l' \\\\oplus last$$$, $$$r = r' \\\\oplus last$$$, $$$x = x' \\\\oplus last$$$and, if $$$l > r$$$, swap $$$l$$$ and $$$r$$$.This means you got an update that the bitwise xor of the subarray $$$[l, r]$$$ is equal to $$$x$$$ (notice that you need to ignore updates that contradict previous updates).If $$$t = 2$$$, two integers follow, $$$l'$$$ and $$$r'$$$ ($$$0 \\\\leq l', r' < 2^{30}$$$), meaning that you got a query.First, do the following:$$$l = l' \\\\oplus last$$$, $$$r = r' \\\\oplus last$$$and, if $$$l > r$$$, swap $$$l$$$ and $$$r$$$.For the given query, you need to print the bitwise xor of the subarray $$$[l, r]$$$. If it is impossible to know, print$$$-1$$$.Don't forget to change the value of $$$last$$$.It is guaranteed there will be at least one query of the second type.OutputAfter every query of the second type, output the bitwise xor of the given subarray or$$$-1$$$if it is still impossible to know.ExamplesInput122 1 22 1 10737418221 0 3 42 0 02 3 32 0 31 6 7 32 4 41 0 2 12 0 02 4 42 0 0Output-1-1-1-15-1635Input41 5 5 91 6 6 51 6 5 102 6 5Output12NoteIn the first example, the real queries (without being encoded) are:122 1 22 0 10737418231 1 2 52 1 12 2 22 1 21 2 3 62 1 11 1 3 02 1 12 2 22 3 3The answers for the first two queries are $$$-1$$$ because we don't have any such information on the array initially.The first update tells us $$$a_1 \\\\oplus a_2 = 5$$$. Note that we still can't be certain about the values $$$a_1$$$ or $$$a_2$$$ independently (for example, it could be that $$$a_1 = 1, a_2 = 4$$$, and also $$$a_1 = 3, a_2 = 6$$$).After we receive all three updates, we have enough information to deduce $$$a_1, a_2, a_3$$$ independently.In the second example, notice that after the first two updates we already know that $$$a_5 \\\\oplus a_6 = 12$$$, so the third update is contradicting, and we ignore it.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "160cf28b", "template_md5": "35d339e4", "result": "You are given an array of $2^{30}$ integers. You don't know the values of the integers initially, but you know that each integer is between 0 and $2^{30}-1$.\n\nYou will be given two types of queries:\n\n1. **Update:** You are given three integers $l$, $r$, and $x$. This means the bitwise XOR of the subarray from index $l$ to $r$ (inclusive) is equal to $x$.  If a new update contradicts a previous update, ignore the new update.\n2. **Query:** You are given two integers $l$ and $r$. You need to find the bitwise XOR of the subarray from index $l$ to $r$ (inclusive). If it's impossible to determine the XOR based on the updates you've received, output $-1$.\n\n**Important:**\n\n* The queries are encoded. You need to apply the following transformations to each query before processing it:\n    * For update queries:\n        *  Let $last$ be the answer to the last query of type 2 you answered (initially, $last = 0$). If the last answer was $-1$, set $last = 1$.\n        * Calculate $l = l' \\oplus last$, $r = r' \\oplus last$, and $x = x' \\oplus last$, where $l'$, $r'$, and $x'$ are the original values in the query.\n        * If $l > r$, swap $l$ and $r$.\n    * For query queries:\n        * Let $last$ be the answer to the last query of type 2 you answered (initially, $last = 0$). If the last answer was $-1$, set $last = 1$.\n        * Calculate $l = l' \\oplus last$ and $r = r' \\oplus last$, where $l'$ and $r'$ are the original values in the query.\n        * If $l > r$, swap $l$ and $r$.\n* After each query of type 2, update the value of $last$ to be the answer you just calculated.\n\n\n\nLet me know if you have any other questions."}, {"prompt_md5": "d62c2fe5", "template_md5": "465699a0", "result": "You are given a list of numbers. You can receive updates that tell you the sum of a range of numbers in the list using the XOR operation. You can also ask for the sum of a range of numbers. If the sum cannot be determined from the updates, you should say -1."}]}