{"uid": "1909-B", "url": "https://codeforces.com/contest/1909/problem/B", "tags": ["bitmasks", " constructive algorithms", " math", " number theory"], "title": "1909-B", "statement": "B. Make Almost Equal With Modtime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputxi - Solar Storm⠀You are given an array $$$a_1, a_2, \\\\dots, a_n$$$ of distinct positive integers. You have to do the following operationexactly once:choose a positive integer $$$k$$$;for each $$$i$$$ from $$$1$$$ to $$$n$$$, replace $$$a_i$$$ with $$$a_i \\\\text{ mod } k^\\\\dagger$$$.Find a value of $$$k$$$ such that $$$1 \\\\leq k \\\\leq 10^{18}$$$ and the array $$$a_1, a_2, \\\\dots, a_n$$$ containsexactly$$$2$$$ distinct values at the end of the operation. It can be shown that, under the constraints of the problem, at least one such $$$k$$$ always exists. If there are multiple solutions, you can print any of them.$$$^\\\\dagger$$$ $$$a \\\\text{ mod } b$$$ denotes the remainder after dividing $$$a$$$ by $$$b$$$. For example:$$$7 \\\\text{ mod } 3=1$$$ since $$$7 = 3 \\\\cdot 2 + 1$$$$$$15 \\\\text{ mod } 4=3$$$ since $$$15 = 4 \\\\cdot 3 + 3$$$$$$21 \\\\text{ mod } 1=0$$$ since $$$21 = 21 \\\\cdot 1 + 0$$$InputEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\\\le t \\\\le 500$$$). The description of the test cases follows.The first line of each test case contains a single integer $$$n$$$ ($$$2 \\\\le n \\\\le 100$$$) — the length of the array $$$a$$$.The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\\\ldots, a_n$$$ ($$$1 \\\\le a_i \\\\le 10^{17}$$$) — the initial state of the array. It is guaranteed that all the $$$a_i$$$ are distinct.Note that there are no constraints on the sum of $$$n$$$ over all test cases.OutputFor each test case, output a single integer: a value of $$$k$$$ ($$$1 \\\\leq k \\\\leq 10^{18}$$$) such that the array $$$a_1, a_2, \\\\dots, a_n$$$ contains exactly $$$2$$$ distinct values at the end of the operation.ExampleInput548 15 22 30560 90 98 120 3086328 769 541 986 215 73451000 2000 7000 11000 1600022 1Output7 30 3 5000 1000000000000000000NoteIn the first test case, you can choose $$$k = 7$$$. The array becomes $$$[8 \\\\text{ mod } 7, 15 \\\\text{ mod } 7, 22 \\\\text{ mod } 7, 30 \\\\text{ mod } 7] = [1, 1, 1, 2]$$$, which contains exactly $$$2$$$ distinct values ($$$\\\\{1, 2\\\\}$$$).In the second test case, you can choose $$$k = 30$$$. The array becomes $$$[0, 0, 8, 0, 8]$$$, which contains exactly $$$2$$$ distinct values ($$$\\\\{0, 8\\\\}$$$). Note that choosing $$$k = 10$$$ would also be a valid solution.In the last test case, you can choose $$$k = 10^{18}$$$. The array becomes $$$[2, 1]$$$, which contains exactly $$$2$$$ distinct values ($$$\\\\{1, 2\\\\}$$$). Note that choosing $$$k = 10^{18} + 1$$$ would not be valid, because $$$1 \\\\leq k \\\\leq 10^{18}$$$ must be true.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "a4b20ac3", "template_md5": "35d339e4", "result": "You are given an array of distinct positive integers. You can choose a positive integer $k$ and modify each element of the array by taking its remainder when divided by $k^2$ (i.e., $a_i \\text{ mod } k^2$). \n\nFind the smallest possible value of $k$ (between 1 and $10^{18}$) that will result in the array having exactly two distinct values after the modification. \n\n**Input:**\n\n* The first line contains the number of test cases, $t$.\n* For each test case:\n    * The first line contains the length of the array, $n$.\n    * The second line contains $n$ distinct positive integers, representing the array.\n\n**Output:**\n\nFor each test case, output a single integer, the value of $k$ that satisfies the condition."}, {"prompt_md5": "ceeb4bd4", "template_md5": "465699a0", "result": "You are given a list of distinct numbers. You can choose a number *k* and change each number in the list to its remainder when divided by *k*. Find the smallest *k* that results in the list having only two unique numbers."}]}