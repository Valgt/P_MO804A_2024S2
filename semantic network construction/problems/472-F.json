{"uid": "472-F", "url": "https://codeforces.com/contest/472/problem/F", "tags": ["constructive algorithms", " math", " matrices"], "title": "472-F", "statement": "F. Design Tutorial: Change the Goaltime limit per test2 secondsmemory limit per test256 megabytesinputstdinoutputstdoutThere are some tasks which have the following structure: you are given a model, and you can do some operations, you should use these operations to achive the goal. One way to create a new task is to use the same model and same operations, but change the goal.Let's have a try. I have created the following task for Topcoder SRM 557 Div1-Hard: you are givennintegersx1,x2, ...,xn. You are allowed to perform the assignments (as many as you want) of the following formxi^=xj(in the original taskiandjmust be different, but in this task we allowito equalj). The goal is to maximize the sum of allxi.Now we just change the goal. You are also givennintegersy1,y2, ...,yn. You should makex1,x2, ...,xnexactly equal toy1,y2, ...,yn. In other words, for eachinumberxishould be equal toyi.InputThe first line contains an integern(1 ≤n≤ 10000). The second line containsnintegers:x1toxn(0 ≤xi≤ 109). The third line containsnintegers:y1toyn(0 ≤yi≤ 109).OutputIf there is no solution, output-1.If there is a solution, then in the first line output an integerm(0 ≤m≤ 1000000)– the number of assignments you need to perform. Then printmlines, each line should contain two integersiandj(1 ≤i,j≤n), which denote assignmentxi^=xj.If there are multiple solutions you can print any of them. We can prove that under these constraints if there exists a solution then there always exists a solution with no more than106operations.ExamplesInput23 56 0Output21 22 2Input50 0 0 0 01 2 3 4 5Output-1Input34 5 61 2 3Output53 11 22 22 33 1Input31 2 34 5 6Output-1NoteAssignmenta^=bdenotes assignmenta=a^b, where operation \"^\" is bitwise XOR of two integers.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "5c1d8208", "template_md5": "35d339e4", "result": "You are given two arrays of integers,  $x$ and $y$, both of length $n$. You can perform the following operation any number of times:\n\n* Choose two indices $i$ and $j$ (which can be the same) and set $x_i = x_i \\oplus x_j$, where $\\oplus$ represents the bitwise XOR operation.\n\nThe goal is to make all elements of array $x$ equal to the corresponding elements in array $y$. \n\nIf it is possible to achieve this, output the minimum number of operations required. Also, list the pairs $(i, j)$ for each operation. If it is not possible to make the arrays equal, output -1."}, {"prompt_md5": "9d95fef8", "template_md5": "465699a0", "result": "You are given two lists of numbers.  Your goal is to make the first list equal to the second list by repeatedly performing the following operation on the numbers in the first list: choose two numbers and make one of them equal to the bitwise XOR of the two numbers. If you can't make the lists equal, output -1. Otherwise, output the minimum number of operations needed and list the pairs of numbers you used in each operation."}]}