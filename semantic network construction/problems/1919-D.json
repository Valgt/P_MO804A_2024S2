{"uid": "1919-D", "url": "https://codeforces.com/contest/1919/problem/D", "tags": ["constructive algorithms", " data structures", " dsu", " greedy", " sortings", " trees"], "title": "1919-D", "statement": "D. 01 Treetime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputThere is an edge-weighted complete binary tree with $$$n$$$ leaves. A complete binary tree is defined as a tree where every non-leaf vertex has exactly 2 children. For each non-leaf vertex, we label one of its children as the left child and the other as the right child.The binary tree has a very strange property. For every non-leaf vertex, one of the edges to its children has weight $$$0$$$ while the other edge has weight $$$1$$$. Note that the edge with weight $$$0$$$ can be connected to either its left or right child.You forgot what the tree looks like, but luckily, you still remember some information about the leaves in the form of an array $$$a$$$ of size $$$n$$$. For each $$$i$$$ from $$$1$$$ to $$$n$$$, $$$a_i$$$ represents the distance$$$^\\\\dagger$$$ from the root to the $$$i$$$-th leaf in dfs order$$$^\\\\ddagger$$$. Determine whether there exists a complete binary tree which satisfies array $$$a$$$. Note that youdo notneed to reconstruct the tree.$$$^\\\\dagger$$$ The distance from vertex $$$u$$$ to vertex $$$v$$$ is defined as the sum of weights of the edges on the path from vertex $$$u$$$ to vertex $$$v$$$.$$$^\\\\ddagger$$$ The dfs order of the leaves is found by calling the following $$$\\\\texttt{dfs}$$$ function on the root of the binary tree.dfs_order = []function dfs(v):if v is leaf:append v to the back of dfs_orderelse:dfs(left child of v)dfs(right child of v)dfs(root)InputEach test contains multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\\\leq t \\\\leq 10^4$$$) — the number of test cases. The description of the test cases follows.The first line of each test case contains a single integer $$$n$$$ ($$$2 \\\\le n \\\\le 2\\\\cdot 10^5$$$) — the size of array $$$a$$$.The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\\\ldots, a_n$$$ ($$$0 \\\\le a_i \\\\le n - 1$$$) — the distance from the root to the $$$i$$$-th leaf.It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2\\\\cdot 10^5$$$.OutputFor each test case, print \"YES\" if there exists a complete binary tree which satisfies array $$$a$$$ and \"NO\" otherwise.You may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as a positive answer).ExampleInput252 1 0 1 151 0 2 1 3OutputYES NONoteIn the first test case, the following tree satisfies the array.In the second test case, it can be proven that there is no complete binary tree that satisfies the array.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "7b3358dd", "template_md5": "35d339e4", "result": "You are given an array $a$ of size $n$ where $a_i$ represents the distance from the root to the $i$-th leaf in a complete binary tree.  A complete binary tree is a tree where every non-leaf vertex has exactly two children. For each non-leaf vertex, one edge to its children has weight 0 and the other has weight 1.\n\nDetermine if there exists a complete binary tree that satisfies the given array $a$. You do not need to construct the tree."}, {"prompt_md5": "7576252a", "template_md5": "465699a0", "result": "You are given a list of distances from the root to each leaf in a binary tree.  Determine if a valid complete binary tree with these distances exists."}]}