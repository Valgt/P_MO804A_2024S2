{"uid": "1900-F", "url": "https://codeforces.com/contest/1900/problem/F", "tags": ["binary search", " data structures", " implementation"], "title": "1900-F", "statement": "F. Local Deletionstime limit per test3 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputFor an array $$$b_1, b_2, \\\\ldots, b_m$$$, for some $$$i$$$ ($$$1 < i < m$$$), element $$$b_i$$$ is said to be a local minimum if $$$b_i < b_{i-1}$$$ and $$$b_i < b_{i+1}$$$. Element $$$b_1$$$ is said to be a local minimum if $$$b_1 < b_2$$$. Element $$$b_m$$$ is said to be a local minimum if $$$b_m < b_{m-1}$$$.For an array $$$b_1, b_2, \\\\ldots, b_m$$$, for some $$$i$$$ ($$$1 < i < m$$$), element $$$b_i$$$ is said to be a local maximum if $$$b_i > b_{i-1}$$$ and $$$b_i > b_{i+1}$$$. Element $$$b_1$$$ is said to be a local maximum if $$$b_1 > b_2$$$. Element $$$b_m$$$ is said to be a local maximum if $$$b_m > b_{m-1}$$$.Let $$$x$$$ be an array of distinct elements. We define two operations on it:$$$1$$$ — delete all elements from $$$x$$$ that arenotlocal minima.$$$2$$$ — delete all elements from $$$x$$$ that arenotlocal maxima.Define $$$f(x)$$$ as follows. Repeat operations $$$1, 2, 1, 2, \\\\ldots$$$ in that order until you get only one element left in the array. Return that element.For example, take an array $$$[1,3,2]$$$. We will first do type $$$1$$$ operation and get $$$[1, 2]$$$. Then we will perform type $$$2$$$ operation and get $$$[2]$$$. Therefore, $$$f([1,3,2]) = 2$$$.You are given a permutation$$$^\\\\dagger$$$ $$$a$$$ of size $$$n$$$ and $$$q$$$ queries. Each query consists of two integers $$$l$$$ and $$$r$$$ such that $$$1 \\\\le l \\\\le r \\\\le n$$$. The query asks you to compute $$$f([a_l, a_{l+1}, \\\\ldots, a_r])$$$.$$$^\\\\dagger$$$ A permutation of length $$$n$$$ is an array of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array), and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$, but there is $$$4$$$ in the array).InputThe first line contains two integers $$$n$$$ and $$$q$$$ ($$$1 \\\\le n, q \\\\le 10^5$$$) — the length of the permutation $$$a$$$ and the number of queries.The second line contains $$$n$$$ integers $$$a_1, a_2, \\\\ldots, a_n$$$ ($$$1 \\\\le a_i \\\\le n$$$) — the elements of permutation $$$a$$$.The $$$i$$$-th of the next $$$q$$$ lines contains two integers $$$l_i$$$ and $$$r_i$$$ ($$$1 \\\\le l_i \\\\le r_i \\\\le n$$$) — the description of $$$i$$$-th query.OutputFor each query, output a single integer — the answer to that query.ExamplesInput7 5 1 4 3 6 2 7 5 1 1 1 2 2 3 1 4 1 7Output1 1 3 3 3Input10 1 1 2 3 4 5 6 7 8 9 10 1 10Output1NoteIn the first query of the first example, the only number in the subarray is $$$1$$$, therefore it is the answer.In the second query of the first example, our subarray initially looks like $$$[1, 4]$$$. After performing type $$$1$$$ operation we get $$$[1]$$$.In the third query of the first example, our subarray initially looks like $$$[4, 3]$$$. After performing type $$$1$$$ operation we get $$$[3]$$$.In the fourth query of the first example, our subarray initially looks like $$$[1, 4, 3, 6]$$$. After performing type $$$1$$$ operation we get $$$[1, 3]$$$. Then we perform type $$$2$$$ operation and we get $$$[3]$$$.In the fifth query of the first example, our subarray initially looks like $$$[1, 4, 3, 6, 2, 7, 5]$$$. After performing type $$$1$$$ operation we get $$$[1,3,2,5]$$$. After performing type $$$2$$$ operation we get $$$[3,5]$$$. Then we perform type $$$1$$$ operation and we get $$$[3]$$$.In the first and only query of the second example our subarray initially looks like $$$[1,2,3,4,5,6,7,8,9,10]$$$. Here $$$1$$$ is the only local minimum, so only it is left after performing type $$$1$$$ operation.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "15e5d589", "template_md5": "35d339e4", "result": "You are given an array of distinct numbers.  You can perform two operations on the array:\n\n1. Delete all elements that are not local minima. A local minimum is an element that is smaller than its neighbors.\n2. Delete all elements that are not local maxima. A local maximum is an element that is larger than its neighbors.\n\nYou repeat these operations in the order 1, 2, 1, 2, ... until only one element remains.  \n\nFor a given range of numbers within the array, find the remaining element after performing these operations. \n\n\nYou will be given:\n\n* The size of the array  \n* The array itself\n* Multiple queries, each specifying a range within the array. \n\nFor each query, output the single element that remains after performing the operations on the specified range."}, {"prompt_md5": "7bc934a4", "template_md5": "465699a0", "result": "You are given a list of numbers.  You can repeatedly perform two operations:\n\n1. Remove all numbers that are not the lowest number in their local neighborhood.\n2. Remove all numbers that are the highest number in their local neighborhood.\n\nAfter performing these operations repeatedly, what is the single remaining number?\n\nYou need to answer this question for many different sublists of the original list."}]}