{"uid": "750-F", "url": "https://codeforces.com/contest/750/problem/F", "tags": ["constructive algorithms", " implementation", " interactive", " trees"], "title": "750-F", "statement": "F. New Year and Finding Rootstime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputThis is an interactive problem. In the interaction section below you will find the information about flushing the output.The New Year tree of heighthis a perfect binary tree with vertices numbered1through2h- 1in some order. In this problem we assume thathis at least2. The drawing below shows one example New Year tree of height3:Polar bears love decorating the New Year tree and Limak is no exception. To decorate the tree, he must first find its root, i.e. a vertex with exactly two neighbours (assuming thath≥ 2). It won't be easy because Limak is a little bear and he doesn't even see the whole tree. Can you help him?There arettestcases. In each testcase, you should first readhfrom the input. Then you can ask at most16questions of format \"? x\" (without quotes), wherexis an integer between1and2h- 1, inclusive. As a reply you will get the list of neighbours of vertexx(more details in the \"Interaction\" section below). For example, for a tree on the drawing above after asking \"? 1\" you would get a response with3neighbours:4,5and7. Your goal is to find the index of the rootyand print it in the format \"! y\". You will be able to readhfor a next testcase only after printing the answer in a previous testcase and flushing the output.Each tree is fixed from the beginning and it doesn't change during your questions.InputThe first line of the input contains a single integert(1 ≤t≤ 500) — the number of testcases.At the beginning of each testcase you should read from the input a single integerh(2 ≤h≤ 7) — the height of the tree. You can't read the value ofhin a next testcase until you answer a previous testcase.InteractionTo ask a question about neighbours of vertexx, print \"? x\" (without quotes) on a separate line. Note, you must print an end-of-line character after the last character of the line and flush your output to get a response.The response will consist of two lines. The first line will contain a single integerk(1 ≤k≤ 3) — the number of neighbours of vertexx. The second line will containkdistinct integerst1, ...,tk(1 ≤t1< ... <tk≤ 2h- 1) — indices of neighbours of vertexx, gives in the increasing order.After asking at most16questions you have to sayy— the index of the root. Print \"! y\" (without quotes) and an end-of-line character, and flush the output.Each tree is fixed from the beginning and it doesn't change during your questions.You can getIdleness Limit Exceededif you don't print anything or if you forget to flush the output.To flush you can use (just printing a query/answer and end-of-line):fflush(stdout)in C++;System.out.flush()in Java;stdout.flush()in Python;flush(output)in Pascal;See the documentation for other languages.In any moment if the program readsh= 0ork= 0it should immediately terminate normally (for example, calling exit(0)). It means that the system detected incorrect request/output from your program and printed 0 because if can't process your requests anymore. In this case you'll receive verdict \"Wrong Answer\", but if you ignore caseh= 0ork= 0it could lead to \"Runtime Error\", \"Time/Memory limit exceeded\" or any other verdict because your program could read a trash from the closed input stream.Hacking. To hack someone, use the following format:The first line should contain a single integertequal to1(only one testcase is allowed in hacks). The second line should contain a single integerh. Each of next2h- 2lines should contain two distinct integersaiandbi(1 ≤ai,bi≤ 2h- 1), denoting two nodes connected with an edge. The printed edges must form a perfect binary tree of heighth.Of course, contestant programs will not be able to see this input.ExamplesInput1334 5 721 212Output? 1? 5? 6! 5Input221321 221 2433 12 13Output? 1? 3? 3! 3? 6! 1NoteIn the first sample, a tree corresponds to the drawing from the statement.In the second sample, there are two two testcases. A tree in the first testcase has height2and thus3vertices. A tree in the second testcase has height4and thus15vertices. You can see both trees on the drawing below.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "d0446967", "template_md5": "35d339e4", "result": "You are given a perfect binary tree with $h$ levels and $2^h - 1$ nodes, numbered from 1 to $2^h - 1$. Your goal is to find the root of the tree.\n\nYou can ask up to 16 questions about the neighbors of a specific node. Each question is in the format \"? x\", where x is a node number. The answer to a question is a list of the node's neighbors, in increasing order.\n\nAfter asking questions, you need to output the index of the root in the format \"! y\".\n\n**Example:**\n\nIf the tree has height 3, you might ask:\n\n* \"? 1\"\n* \"? 5\"\n* \"? 6\"\n\nAnd then output \"! 5\" if you determine that node 5 is the root."}, {"prompt_md5": "15bb210e", "template_md5": "465699a0", "result": "You are given a binary tree with a known height. You can ask questions about the neighbors of specific nodes in the tree. Your goal is to find the root of the tree (the node with exactly two neighbors) by asking at most 16 questions."}]}