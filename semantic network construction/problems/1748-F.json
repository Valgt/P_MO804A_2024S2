{"uid": "1748-F", "url": "https://codeforces.com/contest/1748/problem/F", "tags": ["bitmasks", " constructive algorithms"], "title": "1748-F", "statement": "F. Circular Xor Reversaltime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputYou have an array $$$a_0, a_1, \\\\ldots, a_{n-1}$$$ of length $$$n$$$. Initially, $$$a_i = 2^i$$$ for all $$$0 \\\\le i \\\\lt n$$$. Note that array $$$a$$$ is zero-indexed.You want to reverse this array (that is, make $$$a_i$$$ equal to $$$2^{n-1-i}$$$ for all $$$0 \\\\le i \\\\lt n$$$). To do this, you can perform the following operation no more than $$$250\\\\,000$$$ times:Select an integer $$$i$$$ ($$$0 \\\\le i \\\\lt n$$$) and replace $$$a_i$$$ by $$$a_i \\\\oplus a_{(i+1)\\\\bmod n}$$$.Here, $$$\\\\oplus$$$ denotes thebitwise XOR operation.Your task is to findanysequence of operations that will result in the array $$$a$$$ being reversed. It can be shown that under the given constraints, a solution always exists.InputThe first line contains a single integer $$$n$$$ ($$$2 \\\\le n \\\\le 400$$$) — the length of the array $$$a$$$.OutputOn the first line print one integer $$$k$$$ ($$$0 \\\\le k \\\\le 250\\\\,000$$$) — the number of operations performed.On the second line print $$$k$$$ integers $$$i_1,i_2,\\\\ldots,i_k$$$ ($$$0 \\\\le i_j \\\\lt n$$$). Here, $$$i_j$$$ should be the integer selected on the $$$j$$$-th operation.Note that you don't need to minimize the number of operations.ExamplesInput2Output3 1 0 1Input3Output9 1 0 1 0 2 1 0 1 0NoteIn the notes, the elements on which the operations are performed are colored red.In the first test case, array $$$a$$$ will change in the following way:$$$[1,\\\\color{red}{2}] \\\\rightarrow [\\\\color{red}{1},3] \\\\rightarrow [2,\\\\color{red}{3}] \\\\rightarrow [2,1]$$$.In the second test case, array $$$a$$$ will change in the following way:$$$[1,\\\\color{red}{2},4] \\\\rightarrow [\\\\color{red}{1},6,4] \\\\rightarrow [7,\\\\color{red}{6},4] \\\\rightarrow [\\\\color{red}{7},2,4] \\\\rightarrow [5,2,\\\\color{red}{4}] \\\\rightarrow [5,\\\\color{red}{2},1] \\\\rightarrow [\\\\color{red}{5},3,1] \\\\rightarrow [6,\\\\color{red}{3},1] \\\\rightarrow [\\\\color{red}{6},2,1] \\\\rightarrow [4,2,1]$$$.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "a504734f", "template_md5": "35d339e4", "result": "You are given an array of $n$ integers. Initially, the array is $[2^0, 2^1, ..., 2^{n-1}]$. You want to reverse the array, making it $[2^{n-1}, 2^{n-2}, ..., 2^0]$.\n\nYou can perform the following operation at most 250,000 times:\n\n* Choose an index $i$ (where $0 \\le i < n$) and replace the element at index $i$ with the bitwise XOR of the element at index $i$ and the element at index $(i+1) \\mod n$.\n\nFind any sequence of operations that will reverse the array. \n\nYou need to output:\n\n1. The number of operations performed.\n2. The indices $i$ chosen for each operation."}, {"prompt_md5": "2be5ab08", "template_md5": "465699a0", "result": "You have an array of numbers. Each number is a power of 2. You can swap any number with the number next to it (wrapping around to the beginning of the array if necessary).  Find a sequence of swaps that will reverse the order of the numbers in the array.  You can perform this swap operation at most 250,000 times."}]}