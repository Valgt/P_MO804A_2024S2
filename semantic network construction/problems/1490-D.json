{"uid": "1490-D", "url": "https://codeforces.com/contest/1490/problem/D", "tags": ["dfs and similar", " divide and conquer", " implementation"], "title": "1490-D", "statement": "D. Permutation Transformationtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputA permutation — is a sequence of length $$$n$$$ integers from $$$1$$$ to $$$n$$$, in which all the numbers occur exactly once. For example, $$$[1]$$$, $$$[3, 5, 2, 1, 4]$$$, $$$[1, 3, 2]$$$ — permutations, and $$$[2, 3, 2]$$$, $$$[4, 3, 1]$$$, $$$[0]$$$ — no.Polycarp was recently gifted a permutation $$$a[1 \\\\dots n]$$$ of length $$$n$$$. Polycarp likes trees more than permutations, so he wants to transform permutation $$$a$$$ into a rooted binary tree. He transforms an array of different integers into a tree as follows:the maximum element of the array becomes the root of the tree;all elements to the left of the maximum — form a left subtree (which is built according to the same rules but applied to the left part of the array), but if there are no elements to the left of the maximum, then the root has no left child;all elements to the right of the maximum — form a right subtree (which is built according to the same rules but applied to the right side of the array), but if there are no elements to the right of the maximum, then the root has no right child.For example, if he builds a tree by permutation $$$a=[3, 5, 2, 1, 4]$$$, then the root will be the element $$$a_2=5$$$, and the left subtree will be the tree that will be built for the subarray $$$a[1 \\\\dots 1] = [3]$$$, and the right one — for the subarray $$$a[3 \\\\dots 5] = [2, 1, 4]$$$. As a result, the following tree will be built:The tree corresponding to the permutation $$$a=[3, 5, 2, 1, 4]$$$.Another example: let the permutation be $$$a=[1, 3, 2, 7, 5, 6, 4]$$$. In this case, the tree looks like this:The tree corresponding to the permutation $$$a=[1, 3, 2, 7, 5, 6, 4]$$$.Let us denote by $$$d_v$$$ the depth of the vertex $$$a_v$$$, that is, the number of edges on the path from the root to the vertex numbered $$$a_v$$$. Note that the root depth is zero. Given the permutation $$$a$$$, for each vertex, find the value of $$$d_v$$$.InputThe first line contains one integer $$$t$$$ ($$$1 \\\\le t \\\\le 100$$$) — the number of test cases. Then $$$t$$$ test cases follow.The first line of each test case contains an integer $$$n$$$ ($$$1 \\\\le n \\\\le 100$$$) — the length of the permutation.This is followed by $$$n$$$ numbers $$$a_1, a_2, \\\\ldots, a_n$$$ — permutation $$$a$$$.OutputFor each test case, output $$$n$$$ values — $$$d_1, d_2, \\\\ldots, d_n$$$.ExampleInput3 5 3 5 2 1 4 1 1 4 4 3 1 2Output1 0 2 3 1  0  0 1 3 2", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "d78b6fb9", "template_md5": "465699a0", "result": "You are given a list of numbers.  You need to build a tree from this list where the largest number is the root.  The rest of the numbers are placed in the tree as left and right children based on their order in the list.  For each number in the list, determine its depth in the tree."}, {"prompt_md5": "03981a1c", "template_md5": "35d339e4", "result": "You are given a permutation of integers from 1 to $n$.  A permutation is a sequence where each number appears exactly once.\n\nYou need to build a rooted binary tree from this permutation.  Here's how:\n\n1. The largest number in the permutation becomes the root of the tree.\n2. All numbers smaller than the root to its left form the left subtree.  If there are no numbers to the left, the root has no left child.\n3. All numbers smaller than the root to its right form the right subtree. If there are no numbers to the right, the root has no right child.\n\nYou recursively apply these rules to build the left and right subtrees.\n\nFor each number in the permutation, find its depth in the resulting tree. The depth of a number is the number of edges on the path from the root to that number. The root has a depth of 0.\n\n\n\nOutput the depth of each number in the permutation."}]}