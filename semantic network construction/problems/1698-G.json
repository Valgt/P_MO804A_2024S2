{"uid": "1698-G", "url": "https://codeforces.com/contest/1698/problem/G", "tags": ["bitmasks", " math", " matrices", " meet-in-the-middle", " number theory"], "title": "1698-G", "statement": "G. Long Binary Stringtime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputThere is a binary string $$$t$$$ of length $$$10^{100}$$$, and initally all of its bits are $$$\\\\texttt{0}$$$. You are given a binary string $$$s$$$, and perform the following operation some times:Select some substring of $$$t$$$, and replace it with its XOR with $$$s$$$.$$$^\\\\dagger$$$After several operations, the string $$$t$$$ has exactly two bits $$$\\\\texttt{1}$$$; that is, there are exactly two distinct indices $$$p$$$ and $$$q$$$ such that the $$$p$$$-th and $$$q$$$-th bits of $$$t$$$ are $$$\\\\texttt{1}$$$, and the rest of the bits are $$$\\\\texttt{0}$$$.Find the lexicographically largest$$$^\\\\ddagger$$$ string $$$t$$$ satisfying these constraints, or report that no such string exists.$$$^\\\\dagger$$$ Formally, choose an index $$$i$$$ such that $$$0 \\\\leq i \\\\leq 10^{100}-|s|$$$. For all $$$1 \\\\leq j \\\\leq |s|$$$, if $$$s_j = \\\\texttt{1}$$$, then toggle $$$t_{i+j}$$$. That is, if $$$t_{i+j}=\\\\texttt{0}$$$, set $$$t_{i+j}=\\\\texttt{1}$$$. Otherwise if $$$t_{i+j}=\\\\texttt{1}$$$, set $$$t_{i+j}=\\\\texttt{0}$$$.$$$^\\\\ddagger$$$ A binary string $$$a$$$ is lexicographically larger than a binary string $$$b$$$ of the same length if in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a bit $$$\\\\texttt{1}$$$ and the corresponding bit in $$$b$$$ is $$$\\\\texttt{0}$$$.InputThe only line of each test contains a single binary string $$$s$$$ ($$$1 \\\\leq |s| \\\\leq 35$$$).OutputIf no string $$$t$$$ exists as described in the statement, output-1. Otherwise, output the integers $$$p$$$ and $$$q$$$ ($$$1 \\\\leq p < q \\\\leq 10^{100}$$$) such that the $$$p$$$-th and $$$q$$$-th bits of the lexicographically maximal $$$t$$$ are $$$\\\\texttt{1}$$$.ExamplesInput1Output1 2Input001Output3 4Input1111Output1 5Input00000Output-1Input00000111110000011111000001111101010Output6 37452687NoteIn the first test, you can perform the following operations. $$$$$$\\\\texttt{00000}\\\\ldots \\\\to \\\\color{red}{\\\\texttt{1}}\\\\texttt{0000}\\\\ldots \\\\to \\\\texttt{1}\\\\color{red}{\\\\texttt{1}}\\\\texttt{000}\\\\ldots$$$$$$In the second test, you can perform the following operations. $$$$$$\\\\texttt{00000}\\\\ldots \\\\to \\\\color{red}{\\\\texttt{001}}\\\\texttt{00}\\\\ldots \\\\to \\\\texttt{0}\\\\color{red}{\\\\texttt{011}}\\\\texttt{0}\\\\ldots$$$$$$In the third test, you can perform the following operations. $$$$$$\\\\texttt{00000}\\\\ldots \\\\to \\\\color{red}{\\\\texttt{1111}}\\\\texttt{0}\\\\ldots \\\\to \\\\texttt{1}\\\\color{red}{\\\\texttt{0001}}\\\\ldots$$$$$$It can be proven that these strings $$$t$$$ are the lexicographically largest ones.In the fourth test, you can't make a single bit $$$\\\\texttt{1}$$$, so it is impossible.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "851ff16b", "template_md5": "35d339e4", "result": "You are given a binary string $s$ of length at most 35.  You start with a binary string $t$ of length $10^{100}$ that is all zeros. You can perform the following operation any number of times:\n\n1. Choose a substring of $t$.\n2. Replace that substring with the XOR of that substring and $s$.\n\nAfter performing these operations, you want the resulting string $t$ to have exactly two 1's.  Find the lexicographically largest such string $t$, or report that no such string exists.\n\nThe lexicographically largest string is the string that comes later in alphabetical order. For example, \"101\" is lexicographically larger than \"011\".\n\nOutput the two positions of the 1's in the lexicographically largest string $t$. If no such string exists, output -1."}, {"prompt_md5": "f4f92d48", "template_md5": "465699a0", "result": "You have a very long string of 0s. You can repeatedly choose a part of the string and flip all the 0s to 1s and 1s to 0s in that part, using a given pattern as a template.  Your goal is to find the longest possible string where exactly two bits are 1 after all the flips, or say it's impossible."}]}