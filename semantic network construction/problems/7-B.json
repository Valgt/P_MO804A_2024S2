{"uid": "7-B", "url": "https://codeforces.com/contest/7/problem/B", "tags": ["implementation"], "title": "7-B", "statement": "B. Memory Managertime limit per test1 secondmemory limit per test64 megabytesinputstdinoutputstdoutThere is little time left before the release of the first national operating system BerlOS. Some of its components are not finished yet — the memory manager is among them. According to the developers' plan, in the first release the memory manager will be very simple and rectilinear. It will support three operations:alloc n— to allocatenbytes of the memory and return the allocated block's identifierx;erase x— to erase the block with the identifierx;defragment— to defragment the free memory, bringing all the blocks as close to the beginning of the memory as possible and preserving their respective order;The memory model in this case is very simple. It is a sequence ofmbytes, numbered for convenience from the first to them-th.The first operationalloc ntakes as the only parameter the size of the memory block that is to be allocated. While processing this operation, a free block ofnsuccessive bytes is being allocated in the memory. If the amount of such blocks is more than one, the block closest to the beginning of the memory (i.e. to the first byte) is prefered. All these bytes are marked as not free, and the memory manager returns a 32-bit integer numerical token that is the identifier of this block. If it is impossible to allocate a free block of this size, the function returnsNULL.The second operationerase xtakes as its parameter the identifier of some block. This operation frees the system memory, marking the bytes of this block as free for further use. In the case when this identifier does not point to the previously allocated block, which has not been erased yet, the function returnsILLEGAL_ERASE_ARGUMENT.The last operationdefragmentdoes not have any arguments and simply brings the occupied memory sections closer to the beginning of the memory without changing their respective order.In the current implementation you are to use successive integers, starting with 1, as identifiers. Each successfulallocoperation procession should return following number. Unsuccessfulallocoperations do not affect numeration.You are to write the implementation of the memory manager. You should output the returned value for eachalloccommand. You should also outputILLEGAL_ERASE_ARGUMENTfor all the failederasecommands.InputThe first line of the input data contains two positive integerstandm(1 ≤t≤ 100;1 ≤m≤ 100), wheret— the amount of operations given to the memory manager for processing, andm— the available memory size in bytes. Then there followtlines where the operations themselves are given. The first operation isalloc n(1 ≤n≤ 100), wherenis an integer. The second one iserase x, wherexis an arbitrary 32-bit integer numerical token. The third operation isdefragment.OutputOutput the sequence of lines. Each line should contain either the result ofallocoperation procession , orILLEGAL_ERASE_ARGUMENTas a result of failederaseoperation procession. Output lines should go in the same order in which the operations are processed. Successful procession ofallocoperation should return integers, starting with 1, as the identifiers of the allocated blocks.ExamplesInput6 10alloc 5alloc 3erase 1alloc 6defragmentalloc 6Output12NULL3", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "544b2e17", "template_md5": "35d339e4", "result": "You are given a memory of size $m$ bytes. You need to implement a simple memory manager that supports the following operations:\n\n* **alloc n:** Allocate a block of $n$ consecutive bytes. If possible, allocate the block closest to the beginning of the memory. Return the identifier of the allocated block (starting from 1). If allocation is not possible, return `NULL`.\n* **erase x:** Free the block with the identifier $x$. If the identifier is invalid, return `ILLEGAL_ERASE_ARGUMENT`.\n* **defragment:**  Move all occupied memory blocks as close to the beginning of the memory as possible without changing their order.\n\nYou need to output the result of each `alloc` operation. For each `erase` operation, output `ILLEGAL_ERASE_ARGUMENT` if the identifier is invalid.\n\n\n\nInput:\n\nThe first line contains two integers, $t$ and $m$, representing the number of operations and the memory size, respectively.\n\nThe following $t$ lines describe the operations:\n\n* `alloc n`: Allocate a block of size $n$.\n* `erase x`: Free the block with identifier $x$.\n* `defragment`: Defragment the memory.\n\nOutput:\n\nOutput the result of each `alloc` operation. For each `erase` operation, output `ILLEGAL_ERASE_ARGUMENT` if the identifier is invalid."}, {"prompt_md5": "4d7d4a7f", "template_md5": "465699a0", "result": "You are given a fixed amount of memory. You need to implement a memory manager that can:\n\n* Allocate a block of a given size, returning a unique identifier for the block. If there isn't enough free space, return `NULL`.\n* Free a block identified by its identifier. If the identifier is invalid, return `ILLEGAL_ERASE_ARGUMENT`.\n* Defragment the memory, moving all used blocks to the beginning while maintaining their order.\n\nOutput the identifier returned for each allocation request."}]}