{"uid": "1867-D", "url": "https://codeforces.com/contest/1867/problem/D", "tags": ["brute force", " constructive algorithms", " dfs and similar", " graphs", " greedy", " implementation"], "title": "1867-D", "statement": "D. Cyclic Operationstime limit per test1 secondmemory limit per test256 megabytesinputstandard inputoutputstandard outputEgor has an array $$$a$$$ of length $$$n$$$, initially consisting of zeros. However, he wanted to turn it into another array $$$b$$$ of length $$$n$$$.Since Egor doesn't take easy paths, only the following operation can be used (possibly zero or several times):choose an array $$$l$$$ of length $$$k$$$ ($$$1 \\\\leq l_i \\\\leq n$$$, all $$$l_i$$$ aredistinct) and change each element $$$a_{l_i}$$$ to $$$l_{(i\\\\%k)+1}$$$ ($$$1 \\\\leq i \\\\leq k$$$).He became interested in whether it is possible to get the array $$$b$$$ using only these operations. Since Egor is still a beginner programmer, he asked you to help him solve this problem.The operation $$$\\\\%$$$ means taking the remainder, that is, $$$a\\\\%b$$$ is equal to the remainder of dividing the number $$$a$$$ by the number $$$b$$$.InputThe first line of the input contains an integer $$$t$$$ ($$$1 \\\\leq t \\\\leq 10^5$$$) - the number of test cases.Each test case consists of two lines. The first line contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\\\leq k \\\\leq n \\\\leq 10^5$$$).The second line contains the array $$$b_1, b_2, \\\\ldots, b_n$$$ ($$$1 \\\\leq b_i \\\\leq n$$$).It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\\\cdot 10^5$$$.OutputFor each test case, output\"YES\"(without quotes) if there is a way to get the array $$$b$$$ using only the given operation. Otherwise, output\"NO\"(without quotes). You can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be accepted as a positive answer.ExampleInput65 32 3 5 3 44 22 4 3 11 113 11 2 35 35 4 3 2 16 11 2 3 1 5 6OutputYES NO YES YES NO NONoteLet's consider the first example:Apply the operation with $$$l$$$ = $$$[1,2,3]$$$. Now $$$a$$$ = $$$[2,3,1,0,0]$$$.Apply the operation with $$$l$$$ = $$$[3,5,4]$$$. Now $$$a$$$ = $$$[2,3,5,3,4]$$$ = $$$b$$$.We see that it is possible to get the array $$$b$$$. Therefore, the answer isYES.In the second example, it can be proven that the array $$$b$$$ cannot be obtained, therefore the answer isNO.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "72ad4302", "template_md5": "35d339e4", "result": "You are given two arrays,  $a$ and $b$, both of length $n$. Array $a$ is initially filled with zeros. You can perform the following operation any number of times:\n\n1. Choose a set of $k$ distinct indices $l_1, l_2, ..., l_k$ from the array $a$ (where $1 \\le l_i \\le n$).\n2. Change each element $a_{l_i}$ to $l_{(i \\mod k) + 1}$.\n\nDetermine if it is possible to transform array $a$ into array $b$ using this operation. \n\nInput:\n\n* $t$: The number of test cases.\n* For each test case:\n    * $n$: The length of the arrays.\n    * $k$: The number of indices to choose in each operation.\n    * $b$: The target array.\n\nOutput:\n\nFor each test case, output \"YES\" if it is possible to transform $a$ into $b$, otherwise output \"NO\"."}, {"prompt_md5": "ee844a45", "template_md5": "465699a0", "result": "You are given two arrays of the same length.  You can perform an operation that changes elements in the first array based on a smaller array of indices.  Determine if it is possible to transform the first array into the second array using this operation."}]}