{"uid": "1469-D", "url": "https://codeforces.com/contest/1469/problem/D", "tags": ["brute force", " constructive algorithms", " math", " number theory"], "title": "1469-D", "statement": "D. Ceil Divisionstime limit per test2 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputYou have an array $$$a_1, a_2, \\\\dots, a_n$$$ where $$$a_i = i$$$.In one step, you can choose two indices $$$x$$$ and $$$y$$$ ($$$x \\\\neq y$$$) and set $$$a_x = \\\\left\\\\lceil \\\\frac{a_x}{a_y} \\\\right\\\\rceil$$$ (ceiling function).Your goal is to make array $$$a$$$ consist of $$$n - 1$$$ ones and $$$1$$$ two in no more than $$$n + 5$$$ steps. Note that you don't have to minimize the number of steps.InputThe first line contains a single integer $$$t$$$ ($$$1 \\\\le t \\\\le 1000$$$) — the number of test cases.The first and only line of each test case contains the single integer $$$n$$$ ($$$3 \\\\le n \\\\le 2 \\\\cdot 10^5$$$) — the length of array $$$a$$$.It's guaranteed that the sum of $$$n$$$ over test cases doesn't exceed $$$2 \\\\cdot 10^5$$$.OutputFor each test case, print the sequence of operations that will make $$$a$$$ as $$$n - 1$$$ ones and $$$1$$$ two in the following format: firstly, print one integer $$$m$$$ ($$$m \\\\le n + 5$$$) — the number of operations; next print $$$m$$$ pairs of integers $$$x$$$ and $$$y$$$ ($$$1 \\\\le x, y \\\\le n$$$; $$$x \\\\neq y$$$) ($$$x$$$ may be greater or less than $$$y$$$) — the indices of the corresponding operation.It can be proven that for the given constraints it's always possible to find a correct sequence of operations.ExampleInput2 3 4Output2 3 2 3 2 3 3 4 4 2 4 2NoteIn the first test case, you have array $$$a = [1, 2, 3]$$$. For example, you can do the following:choose $$$3$$$, $$$2$$$: $$$a_3 = \\\\left\\\\lceil \\\\frac{a_3}{a_2} \\\\right\\\\rceil = 2$$$ and array $$$a = [1, 2, 2]$$$;choose $$$3$$$, $$$2$$$: $$$a_3 = \\\\left\\\\lceil \\\\frac{2}{2} \\\\right\\\\rceil = 1$$$ and array $$$a = [1, 2, 1]$$$.You've got array with $$$2$$$ ones and $$$1$$$ two in $$$2$$$ steps.In the second test case, $$$a = [1, 2, 3, 4]$$$. For example, you can do the following:choose $$$3$$$, $$$4$$$: $$$a_3 = \\\\left\\\\lceil \\\\frac{3}{4} \\\\right\\\\rceil = 1$$$ and array $$$a = [1, 2, 1, 4]$$$;choose $$$4$$$, $$$2$$$: $$$a_4 = \\\\left\\\\lceil \\\\frac{4}{2} \\\\right\\\\rceil = 2$$$ and array $$$a = [1, 2, 1, 2]$$$;choose $$$4$$$, $$$2$$$: $$$a_4 = \\\\left\\\\lceil \\\\frac{2}{2} \\\\right\\\\rceil = 1$$$ and array $$$a = [1, 2, 1, 1]$$$.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "b20c5976", "template_md5": "35d339e4", "result": "You are given an array of numbers where each number is equal to its index (e.g., [1, 2, 3, 4]). You can perform the following operation:\n\n* Choose two different indices *x* and *y* in the array.\n* Set the value at index *x* to the ceiling of the division of the value at index *x* by the value at index *y* (i.e.,  $\\lceil \\frac{a_x}{a_y} \\rceil$).\n\nYour goal is to transform the array so that it contains *n - 1* ones and 1 two, using no more than *n + 5* operations. \n\nYou need to provide a sequence of operations (pairs of indices) that achieve this transformation. \n\n**Input:**\n\n* The first line contains the number of test cases *t*.\n* Each test case has a line containing the length of the array *n*.\n\n**Output:**\n\n* For each test case, output:\n    * The number of operations *m*.\n    * *m* pairs of integers *x* and *y*, representing the indices used in each operation."}, {"prompt_md5": "d976a64c", "template_md5": "465699a0", "result": "You have a list of numbers.  You can repeatedly divide one number in the list by another number in the list, rounding the result up to the nearest whole number. Your goal is to change the list so that it has one \"2\" and the rest are \"1\"s. You need to do this in as few steps as possible."}]}