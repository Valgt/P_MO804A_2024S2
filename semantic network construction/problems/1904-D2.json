{"uid": "1904-D2", "url": "https://codeforces.com/contest/1904/problem/D2", "tags": ["constructive algorithms", " data structures", " divide and conquer", " greedy", " implementation", " sortings"], "title": "1904-D2", "statement": "D2. Set To Max (Hard Version)time limit per test4 secondsmemory limit per test256 megabytesinputstandard inputoutputstandard outputThis is the hard version of the problem. The only differences between the two versions of this problem are the constraints on $$$n$$$ and the time limit. You can make hacks only if all versions of the problem are solved.You are given two arrays $$$a$$$ and $$$b$$$ of length $$$n$$$.You can perform the following operation some (possibly zero) times:choose $$$l$$$ and $$$r$$$ such that $$$1 \\\\leq l \\\\leq r \\\\leq n$$$.let $$$x=\\\\max(a_l,a_{l+1},\\\\ldots,a_r)$$$.for all $$$l \\\\leq i \\\\leq r$$$, set $$$a_i := x$$$.Determine if you can make array $$$a$$$ equal to array $$$b$$$.InputEach test contains multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \\\\leq t \\\\leq 10^4$$$) — the number of test cases. The description of the test cases follows.The first line of each test case contains a single integer $$$n$$$ ($$$1 \\\\le n \\\\le 2 \\\\cdot 10^5$$$) — the length of the arrays.The second line contains $$$n$$$ integers $$$a_1, a_2, \\\\ldots, a_n$$$ ($$$1 \\\\le a_i \\\\le n$$$) — the elements of array $$$a$$$.The third line contains $$$n$$$ integers $$$b_1, b_2, \\\\ldots, b_n$$$ ($$$1 \\\\le b_i \\\\le n$$$) — the elements of array $$$b$$$.It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\\\cdot 10^5$$$.OutputFor each test case, output \"YES\" (without quotes) if you can make $$$a$$$ into $$$b$$$ using any number of operations, and \"NO\" (without quotes) otherwise.You can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).ExampleInput551 2 3 2 41 3 3 2 453 4 2 2 43 4 3 4 453 2 1 1 13 3 3 2 221 11 231 1 22 1 2OutputYES NO YES NO NONoteIn the first test case, we can achieve array $$$b$$$ by applying a single operation: $$$(l,r)=(2,3)$$$.In the second test case, it can be shown we cannot achieve array $$$b$$$ in any amount of operations.In the third test case, we can achieve array $$$b$$$ by applying two operations: $$$(l,r)=(2,5)$$$. followed by $$$(l,r)=(1,3)$$$.In the fourth and fifth test cases, it can be shown we cannot achieve array $$$b$$$ in any amount of operations.", "source": "CF", "vjudge": false, "processed": [{"prompt_md5": "c6a8ce1a", "template_md5": "35d339e4", "result": "You are given two arrays,  *a* and *b*, both of length *n*. You can perform the following operation any number of times:\n\n1. Choose two numbers, *l* and *r*, where 1 ≤ *l* ≤ *r* ≤ *n*.\n2. Find the maximum value  *x*  among the elements *a<sub>l</sub>*, *a<sub>l+1</sub>*, ..., *a<sub>r</sub>*.\n3. Change all the elements from *a<sub>l</sub>* to *a<sub>r</sub>* to be equal to *x*.\n\nDetermine if you can make array *a* equal to array *b* using these operations.\n\n**Input:**\n\n* The first line contains *t* (1 ≤ *t* ≤ 10<sup>4</sup>), the number of test cases.\n* For each test case:\n    * The first line contains *n* (1 ≤ *n* ≤ 2 ⋅ 10<sup>5</sup>), the length of the arrays.\n    * The second line contains *n* integers *a<sub>1</sub>*, *a<sub>2</sub>*, ..., *a<sub>n</sub>* (1 ≤ *a<sub>i</sub>* ≤ *n*).\n    * The third line contains *n* integers *b<sub>1</sub>*, *b<sub>2</sub>*, ..., *b<sub>n</sub>* (1 ≤ *b<sub>i</sub>* ≤ *n*).\n\n**Output:**\n\nFor each test case, output \"YES\" if you can make *a* equal to *b* and \"NO\" otherwise."}, {"prompt_md5": "cc1c389f", "template_md5": "465699a0", "result": "You are given two lists of numbers. You can repeatedly choose a section of the first list and make all the numbers in that section equal to the largest number in that section. Can you make the first list identical to the second list?"}]}